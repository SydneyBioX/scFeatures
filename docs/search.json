[{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_associationstudy.html","id":"association-study-of-the-features-with-the-conditions","dir":"Articles","previous_headings":"","what":"Association study of the features with the conditions","title":"An association study of features with conditions with scFeatures","text":"scFeatures provides function automatically run association study features conditions produce html file visualisation features association result. , first need generate features using scFeatures store result named list format. demonstration purpose, provide example features list. code show step step guide generating hmtl output features list. Inside directory defined output_folder, see html report output name output_report.html.","code":"# here we use the demo data from the package  scfeatures_result <- readRDS(system.file(\"extdata\", \"scfeatures_result.rds\",                              package = \"scFeatures\"))  # here we use the current working directory to save the html output # modify this to save the html file to other directory output_folder <-  tempdir()  run_association_study_report(scfeatures_result, output_folder )"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_associationstudy.html","id":"some-additional-notes-on-creating-the-scfeatures_list","dir":"Articles","previous_headings":"","what":"Some additional notes on creating the scfeatures_list","title":"An association study of features with conditions with scFeatures","text":"generating features using scFeatures, make sure sample information format a_cond_b, sample ID b condition, eg, patient09_cond_nonresponder. can retrieve sample ID corresponding condition running analysis. creating list, name list must use name shown . Otherwise, possible tell feature type list entry create correct visualisation feature type. feature types need provided. feature type missing, section html feature type just left blank.","code":"# example of creating the feature list using the correct naming conventions scfeatures_result <- list(     proportion_raw = proportion_raw,    proportion_logit =   proportion_logit,     proportion_ratio = proportion_ratio,     gene_mean_celltype = gene_mean_celltype,    gene_prop_celltype = gene_prop_celltype,     gene_cor_celltype = gene_cor_celltype,     pathway_gsva = pathway_gsva ,     pathway_mean = pathway_mean,     pathway_prop = pathway_prop,    CCI = CCI ,    gene_mean_aggregated = gene_mean_aggregated ,     gene_cor_aggregated = gene_cor_aggregated ,     gene_prop_aggregated = gene_prop_aggregated,    L_stats  = L_stats ,     morans_I = morans_I,     celltype_interaction = celltype_interaction,    nn_correlation = nn_correlation )"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_associationstudy.html","id":"sessioninfo","dir":"Articles","previous_headings":"","what":"sessionInfo()","title":"An association study of features with conditions with scFeatures","text":"","code":"sessionInfo() ## R version 4.2.1 (2022-06-23) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Debian GNU/Linux 11 (bullseye) ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.13.so ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] BiocStyle_2.24.0 ##  ## loaded via a namespace (and not attached): ##  [1] rstudioapi_0.14     knitr_1.40          magrittr_2.0.3      ##  [4] R6_2.5.1            ragg_1.2.3          rlang_1.0.6         ##  [7] fastmap_1.1.0       stringr_1.4.1       tools_4.2.1         ## [10] xfun_0.33           cli_3.4.1           jquerylib_0.1.4     ## [13] systemfonts_1.0.4   htmltools_0.5.3     yaml_2.3.5          ## [16] digest_0.6.29       rprojroot_2.0.3     pkgdown_2.0.6       ## [19] bookdown_0.30       textshaping_0.3.6   BiocManager_1.30.18 ## [22] purrr_0.3.5         sass_0.4.2          fs_1.5.2            ## [25] memoise_2.0.1       cachem_1.0.6        evaluate_0.17       ## [28] rmarkdown_2.17      stringi_1.7.8       compiler_4.2.1      ## [31] bslib_0.4.0         desc_1.4.2          jsonlite_1.8.2"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"A detailed explanation of scFeatures' features","text":"vignette provides detailed description scFeatures, including description feature category, expected output case studies using generated features classification task survival analysis. quick starting point (TLDR version), please see vignette “Vignette - summary scFeatures functions”. Note scFeatures functions contain ncores argument controls number cores. default 1 core. wish run downstream analysis using generated features (see “Vignette - association study”), please make sure run scFeatures, sample format a_cond_b. sample ID b condition, eg, patient09_cond_nonresponder. can retrieve sample ID corresponding condition running analysis.","code":"library(scFeatures)"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"quick-run-of-scfeatures","dir":"Articles","previous_headings":"","what":"Quick run of scFeatures","title":"A detailed explanation of scFeatures' features","text":"scFeatures can run using one line code scfeatures_result <- scFeatures(data), generates list dataframes containing feature types form samples x features. function uses default settings generate feature types. provide example describes can done spatial proteomics dataset.","code":"data <- readRDS(     system.file(\"extdata\", \"example_scrnaseq.rds\", package = \"scFeatures\") ) data <- process_data(data, normalise = TRUE) #  perform normalisation  scfeatures_result <- scFeatures(data) #> [1] \"generating CCI features\" #--------------------------------------------------------------------------- # read in data #---------------------------------------------------------------------------  data <- readRDS(   system.file(\"extdata\", \"example_scrnaseq.rds\", package = \"scFeatures\") )  # randomly generate some x and y coordinate to make this a  # toy \"spatial proteomics\" data x <- sample(1:100, ncol(data) , replace = T) y <- sample(1:100, ncol(data) , replace = T) data <- makeSeurat(data, spatialCoords = list(x,y)) data <- process_data(data, normalise = T)      # select feature types to compute. feature_types <- c(     \"proportion_raw\", \"pathway_gsva\", \"L_stats\", \"gene_mean_celltype\",     \"gene_prop_aggregated\" )   scfeatures_result <- scFeatures(data,     feature_types = feature_types,     type = \"spatial_p\",     # set to user specified pathways.     geneset = list(         \"pathway_a\" = rownames(data)[1:50],         \"pathway_b\" = rownames(data)[51:100]     ),     # by default uses top variable genes to generate the celltype     # specific gene expression feature, now set to user defined genes.     celltype_genes = data.frame(         celltype = c(rep(\"Naive T Cells\" , 10),  rep( \"Cytotoxic CD8\" , 10)),         marker = c( rownames(data)[1:10],  rownames(data)[11:20])     ),     # by default uses top variable genes to generate the overall     # aggregated gene expression feature category, now set to user     # defined genes.     aggregated_genes =  rownames(data)[1:50],     # by default uses single core     ncores = 8 )"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"scfeatures-on-single-cell-rna-seq-data","dir":"Articles","previous_headings":"","what":"scFeatures on single-cell RNA-seq data","title":"A detailed explanation of scFeatures' features","text":"demonstration purpose, provide subsampled version melanoma pre-treatment dataset [1] used manuscript. scFeatures takes data Seurat object, gene expression stored assay RNA. required metadata celltype sample label. condition label optional, required users wish learn difference disease condition using generated features.","code":"data <- readRDS(     system.file(\"extdata\", \"example_scrnaseq.rds\", package = \"scFeatures\") )  data <- process_data(data) # some pre-processing, including normalisation  # confirm the data contain cell types unique(data$celltype) #> [1] \"Naive T Cells\"          \"Cytotoxic CD8\"          \"CD8, T Effector Memory\"  # confirm the data contain samples unique(data$sample)[1:5] #> [1] \"Pre_P8\"  \"Pre_P27\" \"Pre_P7\"  \"Pre_P20\" \"Pre_P3\"  # disease conditions in this data unique(data$condition) #> [1] \"Responder\"     \"Non-responder\"  # format the patient ID as `a_cond_b` eg, `patient09_cond_nonresponder`. This # is so that we can retrieve the sample ID and the corresponding condition when # running downstream analysis on the generated features data$sample <- paste0(data$sample, \"_cond_\", data$condition) unique(data$sample)[1:5] #> [1] \"Pre_P8_cond_Responder\"      \"Pre_P27_cond_Non-responder\" #> [3] \"Pre_P7_cond_Responder\"      \"Pre_P20_cond_Non-responder\" #> [5] \"Pre_P3_cond_Non-responder\""},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"feature-generation","dir":"Articles","previous_headings":"scFeatures on single-cell RNA-seq data","what":"Feature generation","title":"A detailed explanation of scFeatures' features","text":"demonstrate usage scFeatures extract features scRNA-seq data. Note , type argument, currently supported options : * scrna : stands single-cell RNA-seq data * spatial_p: stands spatial proteomics data * spatial_t: stands spatial transcriptomics data default, type set scrna, therefore necessarily specify type input data scRNA-seq data.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"cell-type-proportions","dir":"Articles","previous_headings":"scFeatures on single-cell RNA-seq data > Feature generation","what":"Cell type proportions","title":"A detailed explanation of scFeatures' features","text":"Proportion raw: untransformed proportion. Proportion logit: logit-transformed proportion value, common transformation used proportional data. Proportion ratio: calculates ratio proportion two cell types. Proportion raw Proportion logit: features form celltype , celltype b, number representing proportions. Proportion ratio: features form celltype vs celltype b, celltype vs celltype c, number representing ratio two cell types.","code":"feature_proportion_raw <- run_proportion_raw(data) feature_proportion_logit <- run_proportion_logit(data) feature_proportion_ratio <- run_proportion_ratio(data)"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"cell-type-specific-gene-expressions","dir":"Articles","previous_headings":"scFeatures on single-cell RNA-seq data > Feature generation","what":"Cell type specific gene expressions","title":"A detailed explanation of scFeatures' features","text":"Detail: feature category aggregate cells across cell type construct various features. default, (features argument provided), restrict top variable genes reduce dimensions feature. argument num_top_gene determines many genes include. Gene mean celltype: cell type specific gene expression. Gene proportion celltype: particular gene, percentage cells cell type expressed. Gene correlation celltype: correlation expressions two given genes cell type. Alternatively, users can provide gene interest features argument. Gene mean celltype: features form gene 1 celltype , gene 2 celltype b … etc, number representing average gene expression given gene across cells given celltype. Gene proportion celltype: features form gene 1 celltype , gene 2 celltype b … etc, number representing average gene expression given gene across cells given celltype. Gene correlation celltype: features form gene 1 vs gene 2 cell type , gene 1 vs gene 3 cell type b … etc, numbers representing correlation two given genes given cell type. Note mitochondria ribosomal genes may interesting look . Therefore, users can choose remove genes using function remove_mito. step optional.","code":"data_remove_mito <- remove_mito(data)  feature_gene_mean_celltype <- run_gene_mean_celltype(data_remove_mito)  # we can provide our own sets of genes genes_of_interest <- data.frame(     marker = c(\"S100A11\", \"GZMB\", \"DUSP1\"),     celltype = c(         \"CD8, T Effector Memory\",         \"CD8, T Effector Memory\",         \"Naive T Cells\"     ) ) feature_gene_prop_celltype <- run_gene_prop_celltype(     data_remove_mito,     genes = genes_of_interest )  # we can change the number to pick ~10 top variables genes per cell type feature_gene_cor_celltype <- run_gene_cor_celltype(     data_remove_mito,     num_top_gene = 10 )"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"cell-type-specific-pathway-expressions","dir":"Articles","previous_headings":"scFeatures on single-cell RNA-seq data > Feature generation","what":"Cell type specific pathway expressions","title":"A detailed explanation of scFeatures' features","text":"pathway_gsva: uses GSVA function calculate gene set enrichment score individual cells, aggregates scores across cells within cell type. pathway_mean: averages gene expression genes pathway. pathway_prop: genes pathway, calculates percentage cells genes expressed cell type. pathway_gsva features form pathway 1 celltype , pathway 2 celltype b … etc, number representing gene set enrichment score given pathway cells given celltype. pathway_mean features form pathway 1 celltype , pathway 2 celltype b … etc, number representing averaged expression given pathway cells given celltype. pathway_prop features form pathway 1 celltype , pathway 2 celltype b … etc, number representing proportion expression given pathway cells given celltype. Note necessarily indicate whether species “Homo sapiens” “Mus musculus”. default “Homo sapiens”.","code":"# This function can take a while. Therefore for larger datasets (eg, over # 30,000 cells), we provide a subsample function to increase the speed. feature_pathway_gsva <- run_pathway_gsva(     data,     geneset = NULL, species = \"Homo sapiens\", subsample = FALSE ) feature_pathway_mean <- run_pathway_mean(data) feature_pathway_prop <- run_pathway_prop(data)"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"cell-type-specific-cell-cell-communications","dir":"Articles","previous_headings":"scFeatures on single-cell RNA-seq data > Feature generation","what":"Cell type specific cell-cell communications","title":"A detailed explanation of scFeatures' features","text":"CCI: uses SingleCellSignalR package calculate cell-cell interaction score ligand recepor pairs. CCI: features form ligand 1 receptor 2 celltype , ligand 1 receptor 2 celltype b … etc, numbers representing cell-cell interaction probability.","code":"feature_CCI <- run_CCI(data)"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"overall-aggregated-gene-expressions","dir":"Articles","previous_headings":"scFeatures on single-cell RNA-seq data > Feature generation","what":"Overall aggregated gene expressions","title":"A detailed explanation of scFeatures' features","text":"Detail: feature types category calculated based aggregated expressions across cells. argument num_top_gene determines many genes include. default (features argument provided), algorithm picks top variable genes. Expected output: Gene mean: features form gene 1, gene 2 … etc, numbers representing averaged gene expression across cells. Gene cor: features form gene 1 vs gene 2, gene 1 vs gene 3 … etc, numbers representing correlation gene expressions. Gene prop: features form gene 1, gene 2 … etc, numbers representing proportion gene expressed across cells.","code":"feature_gene_mean_aggregated <- run_gene_mean(data)  genes_of_interest <- c(\"TIGIT\", \"PDCD1\") feature_gene_cor_aggregated <- run_gene_cor(     data,     genes = genes_of_interest ) # we can change this number to pick 100 top variable genes feature_gene_prop_aggregated <- run_gene_prop(data, num_top_gene = 100)"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"classification-of-conditions-using-the-generated-features","dir":"Articles","previous_headings":"scFeatures on single-cell RNA-seq data","what":"Classification of conditions using the generated features","title":"A detailed explanation of scFeatures' features","text":"build disease prediction model generated features use utilise ClassifyR. output scFeatures matrix sample x feature, ie, row corresponds sample, column corresponds feature, can directly used X. order rows order unique(data$sample). use condition y build classification model disease condition. recommend using ClassifyR::crossValidate cross-validated classification extracted feaures.","code":"# Using the feature type gene mean celltype as an example\")  # inspect the first 5 rows and first 5 columns feature_gene_mean_celltype[1:5, 1:5] #>                            Naive T Cells--NOSIP Naive T Cells--LUC7L3 #> Pre_P8_cond_Responder                 1.3403199             1.3253486 #> Pre_P27_cond_Non-responder            0.9504078             0.9565850 #> Pre_P7_cond_Responder                 0.9230278             0.7445286 #> Pre_P20_cond_Non-responder            0.9472109             0.9359819 #> Pre_P3_cond_Non-responder             0.7099657             1.3188926 #>                            Naive T Cells--ARL6IP4 Naive T Cells--IL2RG #> Pre_P8_cond_Responder                   1.1861664             1.304897 #> Pre_P27_cond_Non-responder              0.0000000             1.018693 #> Pre_P7_cond_Responder                   0.2737271             1.462253 #> Pre_P20_cond_Non-responder              0.4789126             1.944960 #> Pre_P3_cond_Non-responder               0.6994015             1.607346 #>                            Naive T Cells--SNRPD2 #> Pre_P8_cond_Responder                  1.1722461 #> Pre_P27_cond_Non-responder             0.0000000 #> Pre_P7_cond_Responder                  0.8139368 #> Pre_P20_cond_Non-responder             0.4753097 #> Pre_P3_cond_Non-responder              0.4793805  # inspect the dimension of the matrix # this means that there are 12354 features in this feature type dim(feature_gene_mean_celltype) #> [1]   16 3642  # confirm that the rows in in the order of unique(data$sample) all(rownames(feature_gene_mean_celltype) == unique(data$sample)) #> [1] TRUE library(ClassifyR)  # X is the feature type generated # y is the condition for classification X <- feature_gene_mean_celltype y <- data@meta.data[!duplicated(data$sample), ] y <- y[match(rownames(X), y$sample), ]$condition  # run the classification model using random forest result <- ClassifyR::crossValidate(     X, y,     classifier = \"randomForest\", nCores = 8,     nFolds = 3, nRepeats = 20 )  ClassifyR::performancePlot(results = result)"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"scfeatures-on-spatial-proteomics-data","dir":"Articles","previous_headings":"","what":"scFeatures on spatial proteomics data","title":"A detailed explanation of scFeatures' features","text":"demonstration purpose, “generate” spatial proteomics data single cell RNA-seq data randomly generating x y - coordinates.","code":"data <- readRDS(   system.file(\"extdata\", \"example_scrnaseq.rds\", package = \"scFeatures\") )  # randomly generate some x and y coordinate to make this a  # toy \"spatial proteomics\" data x <- sample(1:100, ncol(data) , replace = T) y <- sample(1:100, ncol(data) , replace = T) data <- makeSeurat(data, spatialCoords = list(x,y)) data <- process_data(data, normalise = T)    # how the x- and y- coordinates look like  data$x_cord[1:5] #>   E6_P3_MMD4_L001    B2_P3_M91_L001 H1_P7_M60.B1_L001    E3_P1_M53_L001  #>                37                 3                81                21  #>         G3_P2_M17  #>                38"},{"path":[]},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"cell-type-specific-proportions","dir":"Articles","previous_headings":"scFeatures on spatial proteomics data > Feature generation","what":"Cell type specific proportions","title":"A detailed explanation of scFeatures' features","text":"spatial proteomics, need set type spatial_p","code":"feature_proportion_raw <- run_proportion_raw(data, type = \"spatial_p\") feature_proportion_logit <- run_proportion_logit(data, type = \"spatial_p\") feature_proportion_ratio <- run_proportion_ratio(data, type = \"spatial_p\")"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"cell-type-specific-gene-expressions-1","dir":"Articles","previous_headings":"scFeatures on spatial proteomics data > Feature generation","what":"Cell type specific gene expressions","title":"A detailed explanation of scFeatures' features","text":"default, feature category calculates gene/protein expression based top 100 variable genes/proteins per cell type. However, data measured 38 proteins, proteins used.","code":"feature_gene_mean_celltype <- run_gene_mean_celltype(data, type = \"spatial_p\") feature_gene_prop_celltype <- run_gene_prop_celltype(data, type = \"spatial_p\") feature_gene_cor_celltype <- run_gene_cor_celltype(data, type = \"spatial_p\")"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"overall-aggregated-gene-expressions-1","dir":"Articles","previous_headings":"scFeatures on spatial proteomics data > Feature generation","what":"Overall aggregated gene expressions","title":"A detailed explanation of scFeatures' features","text":"default, feature category calculates gene/protein expression based top 1500 variable genes/proteins. However, data 38 proteins, use proteins.","code":"feature_gene_mean_aggregated <- run_gene_mean(data, type = \"spatial_p\") feature_gene_prop_aggregated <- run_gene_prop(data, type = \"spatial_p\") feature_gene_cor_aggregated <- run_gene_cor(data, type = \"spatial_p\")"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"spatial-metrics","dir":"Articles","previous_headings":"scFeatures on spatial proteomics data > Feature generation","what":"Spatial metrics","title":"A detailed explanation of scFeatures' features","text":"L_function: L values pairs proteins calculated using L function defined literature[2]. L value greater zero indicates spatial attraction pair proteins whereas L value less zero indicates spatial repulsion. Morans_I: Moran’s calculated using function defined literature [3]. calculates spatial autocorrelation based locations values simultaneously. value closer 1 indicates clustering similar values value closer -1 indicates clustering dissimilar values. value 0 indicates particular clustering structure, ie, values spatially distributed randomly. celltype_interaction: find nearest neighbours cell cell types neighbours. considered spatial interaction pairs. cell type composition spatial interaction pairs used features. nn_correlation: Pearson’s correlation calculated protein expression cell nearest neighbour cell spatial proteomics. L_function: features form protein 1 vs protein 2, protein 1 vs protein 3 … etc, numbers representing L values. Morans_I: features form protein 1, protein 2 … etc, numbers representing Moran’s value. celltype_interaction: features form protein 1 vs protein 2, protein 1 vs protein 3 … etc, numbers representing proportion interaction pairs give sample. nn_correlation: features form protein 1, protein 2 … etc, numbers representing Pearson’s correlation.","code":"feature_L_stats <- run_L_function(data, type = \"spatial_p\") feature_morans_I <- run_Morans_I(data, type = \"spatial_p\") feature_celltype_interaction <- run_celltype_interaction(     data,     type = \"spatial_p\" ) feature_nn_correlation <- run_nn_correlation(data, type = \"spatial_p\")"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"survival-analysis-using-the-generated-features","dir":"Articles","previous_headings":"scFeatures on spatial proteomics data","what":"Survival analysis using the generated features","title":"A detailed explanation of scFeatures' features","text":"Suppose want use features perform survival analysis, “generate” random survival data.","code":"library(survival) library(survminer)  nncor <- t(feature_nn_correlation) nncor <- nncor[, !colSums(nncor)==0] # run hierarchical clustering hclust_res <- hclust(     as.dist(1 - cor(nncor, method = \"pearson\")),     method = \"ward.D2\" )  # generate some survival outcome survival_day <- sample(1:100, ncol(nncor)) censoring <- sample(0:1, ncol(nncor), replace = T)  cluster_res <- cutree(hclust_res, k = 2) metadata <- data.frame( cluster = factor(cluster_res),                         survival_day = survival_day,                         censoring = censoring)  # plot survival curve fit <- survfit(     Surv(survival_day, censoring) ~ cluster,     data = metadata ) ggsurv <- ggsurvplot(fit,     conf.int = FALSE, risk.table = TRUE,     risk.table.col = \"strata\", pval = TRUE ) ggsurv"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"scfeatures-on-spatial-transcriptomics-data","dir":"Articles","previous_headings":"","what":"scFeatures on spatial transcriptomics data","title":"A detailed explanation of scFeatures' features","text":"demonstration purpose, also “generate” spatial transciptomics single-cell RNA-seq data. spatial transcriptomics, required information sample, x_cord y_cord (x- y- coordinates spot). Additionally, two assays needed, RNA, contains gene expression spot predictions. predictions assay matrix form cell types x spot, stores cell type probability spot. can obtained performing cell type prediction using reference data, example, using SCTransform Seurat (see https://satijalab.org/seurat/articles/spatial_vignette.html#integration--single-cell-data-1). purpose cell type probability matrix due spatial transcriptomics assay contain multiple cells multiple cell type populations, cell type prediction necessary generating cell type specific feature types.","code":"data <- readRDS(   system.file(\"extdata\", \"example_scrnaseq.rds\", package = \"scFeatures\") )  # generate a toy \"spatial transcriptomics\" data data$celltype <- NULL #spatial transcriptomics don't have celltype   # randomly generate some x and y coordinates x <- sample(1:100, ncol(data) , replace = T) y <- sample(1:100, ncol(data) , replace = T)  # for spatial transcriptomics, we need to estimate the number of cells per spot data <- get_num_cell_per_spot(data)  # also need a dataframe of celltype probability at each spot  # here we randomly create one  nrow <- 5 #pretend there are 5 cell types  ncol <- ncol(data)   # Create a matrix of random numbers matrix <- matrix(runif(nrow * ncol), nrow, ncol) # Normalize the columns of the matrix so that each column sum to 1 prediction.scores <-  sweep(matrix, 2, colSums(matrix), \"/\") colnames(prediction.scores) <- colnames(data) rownames(prediction.scores) <- c(paste0(\"celltype\", 1:5))  # format the data using makeSeurat data <- makeSeurat(data, spatialCoords = list(x,y), spotProbability = prediction.scores) data <- process_data(data, normalise = T)       # how the prediction assay look like # the rows contain the predicted cell type probability of each spot data@assays$predictions[, 1] #>                            E6_P3_MMD4_L001 #> prediction.score.celltype1      0.06454154 #> prediction.score.celltype2      0.18199502 #> prediction.score.celltype3      0.19232122 #> prediction.score.celltype4      0.38186122 #> prediction.score.celltype5      0.17928100  # confirm the data include samples unique(data$sample)[1:5] #> [1] \"Pre_P8\"  \"Pre_P6\"  \"Pre_P27\" \"Pre_P7\"  \"Pre_P20\"  # conditions in this data unique(data$condition) #> [1] \"Responder\"     \"Non-responder\"  # format the patient ID as `a_cond_b` eg, `patient09_cond_nonresponder`. This is # so that we can retrieve the sample ID and the corresponding condition when # running downstream analysis on the generated features data$sample <- paste0(data$sample, \"_cond_\", data$condition)"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"feature-generation-2","dir":"Articles","previous_headings":"scFeatures on spatial transcriptomics data","what":"Feature generation","title":"A detailed explanation of scFeatures' features","text":"spatial transcriptomics, spot contains multiple cells potentially multiple cell types. Therefore, implementation feature categories involving cell type specific features (.e., cell type proportions, cell type specific gene expressions, cell type specific pathway expressions, spatial metrics) different implementations single-cell based datasets (.e., scRNA-seq spatial proteomics) described details .","code":""},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"cell-type-proportions-1","dir":"Articles","previous_headings":"scFeatures on spatial transcriptomics data > Feature generation","what":"Cell type proportions","title":"A detailed explanation of scFeatures' features","text":"Detail: spatial transriptomics, measurement spot taken multiple cells, can use cell type probability matrix relative number cells spot jointly estimate cell type proportion sample. Expected output: output format scRNA-seq data.","code":"feature_proportion_raw <- run_proportion_raw(data, type = \"spatial_t\") feature_proportion_logit <- run_proportion_logit(data, type = \"spatial_t\") feature_proportion_ratio <- run_proportion_ratio(data, type = \"spatial_t\")"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"cell-type-specific-gene-expressions-2","dir":"Articles","previous_headings":"scFeatures on spatial transcriptomics data > Feature generation","what":"Cell type specific gene expressions","title":"A detailed explanation of scFeatures' features","text":"Detail: use cell type probability obtain regression coefficients gene associated cell type. Expected output: sample, features form gene celltype , gene celltype b … etc, number representing regression coefficient.","code":"data_remove_mito <- remove_mito(data)  feature_gene_mean_celltype <- run_gene_mean_celltype(     data_remove_mito,     type = \"spatial_t\",     genes = rownames(data_remove_mito)[1:100] # to speed up the vignette generation  )"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"cell-type-specific-pathway-expressions-1","dir":"Articles","previous_headings":"scFeatures on spatial transcriptomics data > Feature generation","what":"Cell type specific pathway expressions","title":"A detailed explanation of scFeatures' features","text":"Detail: use approach obtain regression coefficient cell type gene. regression coefficients genes involved particular pathway summed. Expected output: sample, features form pathway celltype , pathway celltype b … etc, number representing summation regression coefficient.","code":"feature_pathway_mean <- run_pathway_mean(     data,     geneset = NULL, species = \"Homo sapiens\", type = \"spatial_t\" )"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"overall-aggregated-gene-expressions-2","dir":"Articles","previous_headings":"scFeatures on spatial transcriptomics data > Feature generation","what":"Overall aggregated gene expressions","title":"A detailed explanation of scFeatures' features","text":"Detail: based expression genes across cells. Expected output: output format scRNA-seq data.","code":"feature_gene_mean_aggregated <- run_gene_mean(data, type = \"spatial_t\") feature_gene_prop_aggregated <- run_gene_prop(data, type = \"spatial_t\") feature_gene_cor_aggregated <- run_gene_cor(data, type = \"spatial_t\")"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"spatial-metrics-1","dir":"Articles","previous_headings":"scFeatures on spatial transcriptomics data > Feature generation","what":"Spatial metrics","title":"A detailed explanation of scFeatures' features","text":"L_function: L values pairs genes calculated using L function defined literature. used estimated cell type proportion spot calculate L function. Morans_I: implementation spatial proteomics. celltype_interaction: assume nearest neighbours cells captured within spot consider spatial interaction pairs. use estimated cell type proportion spot calculate spatial interaction cell types. nn_correlation: Pearson’s correlation calculated gene expression spot nearest neighbour spot. L_function: features form gene 1 vs gene 2, gene 1 vs gene 3 … etc, numbers representing L values. Morans_I: features form gene 1, gene 2 … etc, numbers representing Moran’s value. celltype_interaction: features form gene 1 vs gene 2, gene 1 vs gene 3 … etc, numbers representing proportion interaction pairs give sample. nn_correlation: features form gene 1, gene 2 … etc, numbers representing Pearson’s correlation.","code":"feature_L_stats <- run_L_function(data, type = \"spatial_t\") feature_morans_I <- run_Morans_I(data, type = \"spatial_t\") feature_celltype_interaction <- run_celltype_interaction(     data,     type = \"spatial_t\" ) feature_nn_correlation <- run_nn_correlation(data, type = \"spatial_t\")"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"reference","dir":"Articles","previous_headings":"","what":"Reference","title":"A detailed explanation of scFeatures' features","text":"Sade-Feldman, M., Yizhak, K., Bjorgaard, S. L., Ray, J. P., de Boer, C. G., Jenkins, R. W., … & Hacohen, N.(2018). Defining T cell states associated response checkpoint immunotherapy melanoma. Cell, 175(4), 998-1013. Besag, J. (1977) Discussion Dr Ripley’s paper. Journal Royal Statistical Society, Series B, 39, 193–195. Moran, P. . P. (1950).”Notes Continuous Stochastic Phenomena”. Biometrika.37 (1) : 17–23. doi:10.2307/2332142","code":""},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_detail.html","id":"sessioninfo","dir":"Articles","previous_headings":"","what":"sessionInfo()","title":"A detailed explanation of scFeatures' features","text":"","code":"sessionInfo() #> R version 4.2.1 (2022-06-23) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Debian GNU/Linux 11 (bullseye) #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.13.so #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] survminer_0.4.9             ggpubr_0.4.0                #>  [3] ggplot2_3.3.6               ClassifyR_3.1.28            #>  [5] survival_3.4-0              BiocParallel_1.30.4         #>  [7] MultiAssayExperiment_1.22.0 SummarizedExperiment_1.26.1 #>  [9] Biobase_2.56.0              GenomicRanges_1.48.0        #> [11] GenomeInfoDb_1.32.4         IRanges_2.30.1              #> [13] MatrixGenerics_1.8.1        matrixStats_0.62.0          #> [15] generics_0.1.3              scFeatures_0.99.9           #> [17] S4Vectors_0.34.0            BiocGenerics_0.42.0         #> [19] BiocStyle_2.24.0            #>  #> loaded via a namespace (and not attached): #>   [1] rsvd_1.0.5                  ica_1.0-3                   #>   [3] Rsamtools_2.12.0            foreach_1.5.2               #>   [5] SingleCellSignalR_1.8.0     lmtest_0.9-40               #>   [7] rprojroot_2.0.3             crayon_1.5.2                #>   [9] spatstat.core_2.4-4         MASS_7.3-58.1               #>  [11] rhdf5filters_1.8.0          nlme_3.1-160                #>  [13] backports_1.4.1             rlang_1.0.6                 #>  [15] XVector_0.36.0              ROCR_1.0-11                 #>  [17] irlba_2.3.5.1               limma_3.52.4                #>  [19] filelock_1.0.2              rjson_0.2.21                #>  [21] bit64_4.0.5                 glue_1.6.2                  #>  [23] pheatmap_1.0.12             sctransform_0.3.5           #>  [25] parallel_4.2.1              spatstat.sparse_3.0-0       #>  [27] AnnotationDbi_1.58.0        spatstat.geom_3.0-3         #>  [29] tidyselect_1.2.0            km.ci_0.5-6                 #>  [31] SeuratObject_4.1.2          fitdistrplus_1.1-8          #>  [33] XML_3.99-0.11               tidyr_1.2.1                 #>  [35] zoo_1.8-11                  GenomicAlignments_1.32.1    #>  [37] xtable_1.8-4                magrittr_2.0.3              #>  [39] evaluate_0.17               scuttle_1.6.3               #>  [41] cli_3.4.1                   zlibbioc_1.42.0             #>  [43] rstudioapi_0.14             miniUI_0.1.1.1              #>  [45] sp_1.5-0                    bslib_0.4.0                 #>  [47] rpart_4.1.16                ensembldb_2.20.2            #>  [49] shiny_1.7.2                 GSVA_1.44.5                 #>  [51] BiocSingular_1.12.0         xfun_0.33                   #>  [53] multtest_2.52.0             cluster_2.1.4               #>  [55] caTools_1.18.2              ggtext_0.1.2                #>  [57] KEGGREST_1.36.3             tibble_3.1.8                #>  [59] ggrepel_0.9.1               ape_5.6-2                   #>  [61] listenv_0.8.0               Biostrings_2.64.1           #>  [63] png_0.1-7                   future_1.28.0               #>  [65] withr_2.5.0                 bitops_1.0-7                #>  [67] ranger_0.14.1               plyr_1.8.7                  #>  [69] GSEABase_1.58.0             AnnotationFilter_1.20.0     #>  [71] pracma_2.4.2                dqrng_0.3.0                 #>  [73] pillar_1.8.1                RcppParallel_5.1.5          #>  [75] gplots_3.1.3                GlobalOptions_0.1.2         #>  [77] cachem_1.0.6                GenomicFeatures_1.48.4      #>  [79] fs_1.5.2                    DelayedMatrixStats_1.18.1   #>  [81] vctrs_0.4.2                 ellipsis_0.3.2              #>  [83] tools_4.2.1                 munsell_0.5.0               #>  [85] DelayedArray_0.22.0         fastmap_1.1.0               #>  [87] compiler_4.2.1              abind_1.4-5                 #>  [89] httpuv_1.6.6                rtracklayer_1.56.1          #>  [91] plotly_4.10.0               rgeos_0.5-9                 #>  [93] GenomeInfoDbData_1.2.8      gridExtra_2.3               #>  [95] edgeR_3.38.4                lattice_0.20-45             #>  [97] deldir_1.0-6                utf8_1.2.2                  #>  [99] later_1.3.0                 dplyr_1.0.10                #> [101] BiocFileCache_2.4.0         jsonlite_1.8.2              #> [103] scales_1.2.1                graph_1.74.0                #> [105] ScaledMatrix_1.4.1          carData_3.0-5               #> [107] pbapply_1.5-0               sparseMatrixStats_1.8.0     #> [109] genefilter_1.78.0           lazyeval_0.2.2              #> [111] promises_1.2.0.1            car_3.1-0                   #> [113] R.utils_2.12.0              goftest_1.2-3               #> [115] spatstat.utils_3.0-1        reticulate_1.26             #> [117] rmarkdown_2.17              pkgdown_2.0.6               #> [119] cowplot_1.1.1               textshaping_0.3.6           #> [121] statmod_1.4.37              Rtsne_0.16                  #> [123] uwot_0.1.14                 igraph_1.3.5                #> [125] HDF5Array_1.24.2            proxyC_0.3.3                #> [127] yaml_2.3.5                  systemfonts_1.0.4           #> [129] htmltools_0.5.3             memoise_2.0.1               #> [131] BiocIO_1.6.0                Seurat_4.2.0                #> [133] locfit_1.5-9.6              viridisLite_0.4.1           #> [135] digest_0.6.29               assertthat_0.2.1            #> [137] mime_0.12                   rappdirs_0.3.3              #> [139] KMsurv_0.1-5                SIMLR_1.22.0                #> [141] RSQLite_2.2.18              future.apply_1.9.1          #> [143] data.table_1.14.2           blob_1.2.3                  #> [145] R.oo_1.25.0                 survMisc_0.5.6              #> [147] ragg_1.2.3                  splines_4.2.1               #> [149] labeling_0.4.2              Rhdf5lib_1.18.2             #> [151] ProtGenerics_1.28.0         gridtext_0.1.5              #> [153] RCurl_1.98-1.9              broom_1.0.1                 #> [155] hms_1.1.2                   rhdf5_2.40.0                #> [157] colorspace_2.0-3            DropletUtils_1.16.0         #> [159] BiocManager_1.30.18         shape_1.4.6                 #> [161] sass_0.4.2                  Rcpp_1.0.9                  #> [163] bookdown_0.30               RANN_2.6.1                  #> [165] circlize_0.4.15             fansi_1.0.3                 #> [167] parallelly_1.32.1           R6_2.5.1                    #> [169] grid_4.2.1                  ggridges_0.5.4              #> [171] lifecycle_1.0.3             bluster_1.6.0               #> [173] curl_4.3.3                  ggsignif_0.6.3              #> [175] leiden_0.4.3                jquerylib_0.1.4             #> [177] SpatialExperiment_1.6.1     Matrix_1.5-3                #> [179] EnsDb.Mmusculus.v79_2.99.0  desc_1.4.2                  #> [181] RcppAnnoy_0.0.19            RColorBrewer_1.1-3          #> [183] iterators_1.0.14            spatstat.explore_3.0-5      #> [185] stringr_1.4.1               htmlwidgets_1.5.4           #> [187] markdown_1.1                beachmat_2.12.0             #> [189] polyclip_1.10-0             biomaRt_2.52.0              #> [191] purrr_0.3.5                 mgcv_1.8-40                 #> [193] globals_0.16.1              patchwork_1.1.2             #> [195] spatstat.random_3.0-1       progressr_0.11.0            #> [197] codetools_0.2-18            metapod_1.4.0               #> [199] gtools_3.9.3                prettyunits_1.1.1           #> [201] SingleCellExperiment_1.18.1 dbplyr_2.2.1                #> [203] EnsDb.Hsapiens.v79_2.99.0   RSpectra_0.16-1             #> [205] R.methodsS3_1.8.2           gtable_0.3.1                #> [207] DBI_1.1.3                   tensor_1.5                  #> [209] httr_1.4.4                  highr_0.9                   #> [211] KernSmooth_2.23-20          stringi_1.7.8               #> [213] progress_1.2.2              reshape2_1.4.4              #> [215] msigdbr_7.5.1               farver_2.1.1                #> [217] annotate_1.74.0             magick_2.7.3                #> [219] xml2_1.3.3                  BiocNeighbors_1.14.0        #> [221] AUCell_1.18.1               restfulr_0.0.15             #> [223] scattermore_0.8             scran_1.24.1                #> [225] bit_4.0.4                   spatstat.data_3.0-0         #> [227] pkgconfig_2.0.3             babelgene_22.9              #> [229] rstatix_0.7.0               knitr_1.40"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_overview.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"A detailed explanation of scFeatures' features","text":"scFeatures tool generating multi-view representations samples single-cell dataset. vignette provides overview scFeatures. uses main function generate features illustrates case studies using generated features classification, survival analysis association study.","code":"library(scFeatures)"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_overview.html","id":"running-scfeatures","dir":"Articles","previous_headings":"","what":"Running scFeatures","title":"A detailed explanation of scFeatures' features","text":"scFeatures can run using one line code scfeatures_result <- scFeatures(data), generates list dataframes containing feature types form samples x features. default, function generates feature types. reduce computational time demonstrate, generate selected feature type “gene mean celltype”. information function customisation can obtained typing ?scFeatures()","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq  scfeatures_result <- scFeatures(data = data@assays$RNA@data, sample = data$sample, celltype = data$celltype,                                 feature_types = \"gene_mean_celltype\"  ,                                  type = \"scrna\",                                   ncores = 1,                                   species = \"Homo sapiens\")"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_overview.html","id":"classification-of-conditions-using-the-generated-features","dir":"Articles","previous_headings":"Running scFeatures","what":"Classification of conditions using the generated features","title":"A detailed explanation of scFeatures' features","text":"build disease prediction model generated features utilise ClassifyR. output scFeatures matrix sample x feature, ie, row corresponds sample, column corresponds feature, can directly used X. order rows order unique(data$sample). use feature type gene mean celltype example build classification model disease condition. recommend using ClassifyR::crossValidate cross-validated classification extracted feaures.  expected classification accuracy low. using small subset data containing 3523 genes 519 cells. dataset unlikely contain enough information distinguish responders non-responders.","code":"feature_gene_mean_celltype <- scfeatures_result$gene_mean_celltype  # inspect the first 5 rows and first 5 columns feature_gene_mean_celltype[1:5, 1:5] #>         Naive T Cells--SNRPD2 Naive T Cells--NOSIP Naive T Cells--IL2RG #> Pre_P8              1.6774074             1.856023             1.834704 #> Pre_P6              3.4815573             3.217231             3.583760 #> Pre_P27             0.0000000             1.486346             1.742069 #> Pre_P7              1.1761242             1.282083             2.050024 #> Pre_P20             0.6999054             1.315393             2.781787 #>         Naive T Cells--ALDOA Naive T Cells--LUC7L3 #> Pre_P8              1.598921             1.8056758 #> Pre_P6              3.493135             0.0000000 #> Pre_P27             3.518687             1.5080699 #> Pre_P7              2.575957             0.9163035 #> Pre_P20             1.626403             1.2659969  # inspect the dimension of the matrix dim(feature_gene_mean_celltype) #> [1]   19 2217 library(ClassifyR)  # X is the feature type generated # y is the condition for classification X <- feature_gene_mean_celltype y <- data@meta.data[!duplicated(data$sample), ] y <- y[match(rownames(X), y$sample), ]$condition  # run the classification model using random forest result <- ClassifyR::crossValidate(     X, y,     classifier = \"randomForest\", nCores = 2,     nFolds = 3, nRepeats = 5 )  ClassifyR::performancePlot(results = result)"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_overview.html","id":"survival-analysis-using-the-generated-features","dir":"Articles","previous_headings":"Running scFeatures","what":"Survival analysis using the generated features","title":"A detailed explanation of scFeatures' features","text":"Suppose want use features perform survival analysis. , since patient outcomes responder non-responder, contain survival information, randomly “generate” survival outcome purpose demonstration. use standard hierarchical clustering split patients 2 groups based generated features.  p-value high, indicating enough evidence claim survival difference two groups. expected, randomly assigned survival status patient.","code":"library(survival) library(survminer)    X <- feature_gene_mean_celltype X <- t(X)  # run hierarchical clustering hclust_res <- hclust(     as.dist(1 - cor(X, method = \"pearson\")),     method = \"ward.D2\" )  set.seed(1) # generate some survival outcome, including the survival days and the censoring outcome survival_day <- sample(1:100, ncol(X)) censoring <- sample(0:1, ncol(X), replace = TRUE)  cluster_res <- cutree(hclust_res, k = 2) metadata <- data.frame( cluster = factor(cluster_res),                         survival_day = survival_day,                         censoring = censoring)  # plot survival curve fit <- survfit(     Surv(survival_day, censoring) ~ cluster,     data = metadata ) ggsurv <- ggsurvplot(fit,     conf.int = FALSE, risk.table = TRUE,     risk.table.col = \"strata\", pval = TRUE ) ggsurv"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_overview.html","id":"association-study-of-the-features-with-the-conditions","dir":"Articles","previous_headings":"","what":"Association study of the features with the conditions","title":"A detailed explanation of scFeatures' features","text":"scFeatures provides function automatically run association study features conditions produce HTML file visualisation features association result. , first need generate features using scFeatures store result named list format. demonstration purpose, provide example features list. code show steps generating HTML output features list. Inside directory defined output_folder, see html report output name output_report.html.","code":"# here we use the demo data from the package  data(\"scfeatures_result\" , package = \"scFeatures\")  # here we use the current working directory to save the html output # modify this to save the html file to other directory output_folder <-  tempdir()  run_association_study_report(scfeatures_result, output_folder ) #> /usr/lib/rstudio-server/bin/quarto/bin/tools/pandoc +RTS -K512m -RTS output_report.knit.md --to html4 --from markdown+autolink_bare_uris+tex_math_single_backslash --output /tmp/Rtmpyj1RBw/output_report.html --lua-filter /dora/nobackup/yuec/R/rmarkdown/rmarkdown/lua/pagebreak.lua --lua-filter /dora/nobackup/yuec/R/rmarkdown/rmarkdown/lua/latex-div.lua --embed-resources --standalone --variable bs3=TRUE --section-divs --table-of-contents --toc-depth 3 --variable toc_float=1 --variable toc_selectors=h1,h2,h3 --variable toc_collapsed=1 --variable toc_print=1 --template /dora/nobackup/yuec/R/rmarkdown/rmd/h/default.html --no-highlight --variable highlightjs=1 --number-sections --variable theme=bootstrap --mathjax --variable 'mathjax-url=https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML' --include-in-header /tmp/Rtmpyj1RBw/rmarkdown-str2afaf864eb680e.html --variable code_folding=hide --variable code_menu=1"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_overview.html","id":"sessioninfo","dir":"Articles","previous_headings":"","what":"sessionInfo()","title":"A detailed explanation of scFeatures' features","text":"","code":"sessionInfo() #> R version 4.3.1 (2023-06-16) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Debian GNU/Linux 12 (bookworm) #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.21.so;  LAPACK version 3.11.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: Australia/Sydney #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] grid      stats4    stats     graphics  grDevices utils     datasets  #> [8] methods   base      #>  #> other attached packages: #>  [1] data.table_1.14.8           enrichplot_1.20.0           #>  [3] DOSE_3.26.1                 clusterProfiler_4.8.1       #>  [5] msigdbr_7.5.1               EnsDb.Hsapiens.v79_2.99.0   #>  [7] ensembldb_2.24.0            AnnotationFilter_1.24.0     #>  [9] GenomicFeatures_1.52.1      org.Hs.eg.db_3.17.0         #> [11] AnnotationDbi_1.62.2        plotly_4.10.3               #> [13] igraph_1.5.1                tidyr_1.3.0                 #> [15] DT_0.30                     limma_3.56.2                #> [17] pheatmap_1.0.12             dplyr_1.1.3                 #> [19] reshape2_1.4.4              survminer_0.4.9             #> [21] ggpubr_0.6.0                ggplot2_3.4.4               #> [23] ClassifyR_3.5.21            survival_3.5-7              #> [25] BiocParallel_1.34.2         MultiAssayExperiment_1.26.0 #> [27] SummarizedExperiment_1.30.2 Biobase_2.60.0              #> [29] GenomicRanges_1.52.0        GenomeInfoDb_1.36.1         #> [31] IRanges_2.34.1              MatrixGenerics_1.12.2       #> [33] matrixStats_1.0.0           generics_0.1.3              #> [35] SeuratObject_5.0.0          sp_2.1-1                    #> [37] scFeatures_0.99.27          S4Vectors_0.38.1            #> [39] BiocGenerics_0.46.0         BiocStyle_2.28.0            #>  #> loaded via a namespace (and not attached): #>   [1] R.methodsS3_1.8.2           GSEABase_1.62.0             #>   [3] progress_1.2.2              EnsDb.Mmusculus.v79_2.99.0  #>   [5] goftest_1.2-3               Biostrings_2.68.1           #>   [7] HDF5Array_1.28.1            vctrs_0.6.4                 #>   [9] spatstat.random_3.2-1       digest_0.6.33               #>  [11] png_0.1-8                   shape_1.4.6                 #>  [13] ggrepel_0.9.4               deldir_1.0-9                #>  [15] parallelly_1.36.0           MASS_7.3-60                 #>  [17] pkgdown_2.0.7               httpuv_1.6.12               #>  [19] foreach_1.5.2               qvalue_2.32.0               #>  [21] withr_2.5.1                 ggfun_0.1.3                 #>  [23] xfun_0.40                   ellipsis_0.3.2              #>  [25] memoise_2.0.1               proxyC_0.3.4                #>  [27] commonmark_1.9.0            gson_0.1.0                  #>  [29] systemfonts_1.0.5           tidytree_0.4.5              #>  [31] ragg_1.2.6                  zoo_1.8-12                  #>  [33] GlobalOptions_0.1.2         gtools_3.9.4                #>  [35] SingleCellSignalR_1.12.0    R.oo_1.25.0                 #>  [37] prettyunits_1.2.0           KEGGREST_1.40.0             #>  [39] promises_1.2.1              httr_1.4.7                  #>  [41] downloader_0.4              rstatix_0.7.2               #>  [43] restfulr_0.0.15             globals_0.16.2              #>  [45] rhdf5filters_1.12.1         rhdf5_2.44.0                #>  [47] rstudioapi_0.15.0           babelgene_22.9              #>  [49] curl_5.0.2                  zlibbioc_1.46.0             #>  [51] ScaledMatrix_1.8.1          ggraph_2.1.0                #>  [53] polyclip_1.10-6             GenomeInfoDbData_1.2.10     #>  [55] xtable_1.8-4                stringr_1.5.0               #>  [57] desc_1.4.2                  evaluate_0.22               #>  [59] S4Arrays_1.0.6              BiocFileCache_2.8.0         #>  [61] hms_1.1.3                   bookdown_0.36               #>  [63] irlba_2.3.5.1               colorspace_2.1-0            #>  [65] filelock_1.0.2              spatstat.data_3.0-3         #>  [67] magrittr_2.0.3              ggtree_3.8.0                #>  [69] viridis_0.6.4               later_1.3.1                 #>  [71] lattice_0.22-5              spatstat.geom_3.2-7         #>  [73] future.apply_1.11.0         genefilter_1.82.1           #>  [75] shadowtext_0.1.2            XML_3.99-0.14               #>  [77] scuttle_1.10.1              cowplot_1.1.1               #>  [79] ggupset_0.3.0               pillar_1.9.0                #>  [81] nlme_3.1-163                iterators_1.0.14            #>  [83] caTools_1.18.2              compiler_4.3.1              #>  [85] beachmat_2.16.0             stringi_1.7.12              #>  [87] tensor_1.5                  GenomicAlignments_1.36.0    #>  [89] plyr_1.8.9                  crayon_1.5.2                #>  [91] abind_1.4-5                 BiocIO_1.10.0               #>  [93] gridGraphics_0.5-1          ggtext_0.1.2                #>  [95] locfit_1.5-9.8              graphlayouts_1.0.1          #>  [97] bit_4.0.5                   fastmatch_1.1-4             #>  [99] codetools_0.2-19            textshaping_0.3.7           #> [101] BiocSingular_1.16.0         crosstalk_1.2.0             #> [103] bslib_0.5.1                 multtest_2.56.0             #> [105] mime_0.12                   splines_4.3.1               #> [107] markdown_1.11               circlize_0.4.15             #> [109] Rcpp_1.0.11                 dbplyr_2.4.0                #> [111] sparseMatrixStats_1.12.2    HDO.db_0.99.1               #> [113] gridtext_0.1.5              knitr_1.44                  #> [115] blob_1.2.4                  utf8_1.2.4                  #> [117] fs_1.6.3                    listenv_0.9.0               #> [119] DelayedMatrixStats_1.22.1   GSVA_1.48.2                 #> [121] ggplotify_0.1.2             ggsignif_0.6.4              #> [123] tibble_3.2.1                Matrix_1.6-1.1              #> [125] statmod_1.5.0               tweenr_2.0.2                #> [127] pkgconfig_2.0.3             tools_4.3.1                 #> [129] cachem_1.0.8                RSQLite_2.3.1               #> [131] viridisLite_0.4.2           DBI_1.1.3                   #> [133] fastmap_1.1.1               rmarkdown_2.25              #> [135] scales_1.2.1                Rsamtools_2.16.0            #> [137] broom_1.0.5                 sass_0.4.7                  #> [139] patchwork_1.1.3             BiocManager_1.30.22         #> [141] dotCall64_1.1-0             graph_1.78.0                #> [143] carData_3.0-5               farver_2.1.1                #> [145] scatterpie_0.2.1            tidygraph_1.2.3             #> [147] yaml_2.3.7                  rtracklayer_1.60.0          #> [149] cli_3.6.1                   purrr_1.0.2                 #> [151] lifecycle_1.0.3             bluster_1.10.0              #> [153] backports_1.4.1             annotate_1.78.0             #> [155] gtable_0.3.4                rjson_0.2.21                #> [157] progressr_0.14.0            parallel_4.3.1              #> [159] ape_5.7-1                   jsonlite_1.8.7              #> [161] edgeR_3.42.4                bitops_1.0-7                #> [163] bit64_4.0.5                 Rtsne_0.16                  #> [165] yulab.utils_0.1.0           spatstat.utils_3.0-4        #> [167] BiocNeighbors_1.18.0        ranger_0.15.1               #> [169] RcppParallel_5.1.7          jquerylib_0.1.4             #> [171] metapod_1.8.0               GOSemSim_2.26.0             #> [173] dqrng_0.3.1                 survMisc_0.5.6              #> [175] R.utils_2.12.2              lazyeval_0.2.2              #> [177] shiny_1.7.5.1               htmltools_0.5.6.1           #> [179] KMsurv_0.1-5                GO.db_3.17.0                #> [181] rappdirs_0.3.3              glue_1.6.2                  #> [183] spam_2.10-0                 XVector_0.40.0              #> [185] RCurl_1.98-1.12             treeio_1.24.1               #> [187] rprojroot_2.0.3             scran_1.28.1                #> [189] gridExtra_2.3               AUCell_1.22.0               #> [191] R6_2.5.1                    SingleCellExperiment_1.22.0 #> [193] gplots_3.1.3                km.ci_0.5-6                 #> [195] labeling_0.4.3              cluster_2.1.4               #> [197] Rhdf5lib_1.22.0             aplot_0.2.2                 #> [199] DelayedArray_0.26.6         tidyselect_1.2.0            #> [201] ProtGenerics_1.32.0         ggforce_0.4.1               #> [203] xml2_1.3.5                  car_3.1-2                   #> [205] future_1.33.0               rsvd_1.0.5                  #> [207] munsell_0.5.0               KernSmooth_2.23-22          #> [209] htmlwidgets_1.6.2           fgsea_1.26.0                #> [211] RColorBrewer_1.1-3          biomaRt_2.56.1              #> [213] rlang_1.1.1                 spatstat.sparse_3.0-3       #> [215] spatstat.explore_3.2-5      fansi_1.0.5"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_summary.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"An overview of scFeatures' functions","text":"vignette provides overview scFeatures package. scFeatures generates features single-cell RNA-seq, spatial proteomic spatial transcriptomic data. features span across six categories representing different molecular views cellular characteristics. include () cell type proportions, (ii) cell type specific gene expressions, (iii) cell type specific pathway expressions, (iv) cell type specific cell-cell interaction (CCI) scores, (v) overall aggregated gene expressions (vi) spatial metrics. features enable comprehensive multi-view representation expression data can used downstream analysis association study.","code":"library(scFeatures)"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_summary.html","id":"quick-start","dir":"Articles","previous_headings":"","what":"Quick start","title":"An overview of scFeatures' functions","text":"scFeatures can run using one line code scfeatures_result <- scFeatures(data), generates list data frames containing feature types form samples x features. list function generating individual feature types scRNA-seq, spatial proteomic spatial transcriptomic data.","code":"data <- readRDS(   system.file(\"extdata\", \"example_scrnaseq.rds\", package = \"scFeatures\") ) data <- process_data(data, normalise = TRUE) #  perform normalisation  scfeatures_result <- scFeatures(data)"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_summary.html","id":"scfeatures-for-single-cell-rna-seq-data","dir":"Articles","previous_headings":"","what":"scFeatures for single-cell RNA-seq data","title":"An overview of scFeatures' functions","text":"scFeatures accept Seurat object containing sample celltype columns. SingleCellExperiment SpatialExperiment object, provide function makeSeurat() conversion.","code":"#--------------------------------------------------------------------------- # read in data #--------------------------------------------------------------------------- data <- readRDS(   system.file(\"extdata\", \"example_scrnaseq.rds\", package = \"scFeatures\") ) data <- process_data(data, normalise = TRUE) #  perform normalisation  # format the patient ID as `a_cond_b` eg, `patient09_cond_nonresponder`. # This is so that we can retrieve the sample ID and the corresponding condition # when running downstream analysis on the generated features data$sample <- paste0(data$sample, \"_cond_\", data$condition)  #--------------------------------------------------------------------------- # cell type proportions #--------------------------------------------------------------------------- feature_proportion_raw <- run_proportion_raw(data) feature_proportion_logit <- run_proportion_logit(data) feature_proportion_ratio <- run_proportion_ratio(data)   #--------------------------------------------------------------------------- # cell type specific gene expressions #--------------------------------------------------------------------------- # optional step, run if mitochondria amd ribosomal genes are not of interest data_remove_mito <- remove_mito(data)  # by default, use the top variable genes # users can change the number of top variable genes by changing `num_top_gene` # alternatively, users can also input genes of interest in a dataframe format genes_of_interest <- data.frame(     marker = c(\"S100A11\", \"GZMB\", \"DUSP1\"),     celltype = c(       \"CD8, T Effector Memory\",        \"CD8, T Effector Memory\",        \"Naive T Cells\"     ) )  feature_gene_mean_celltype <- run_gene_mean_celltype(data_remove_mito) feature_gene_prop_celltype <- run_gene_prop_celltype(   data_remove_mito, genes = genes_of_interest ) feature_gene_cor_celltype <- run_gene_cor_celltype(   data_remove_mito, num_top_gene = 50 ) # by default, pick around 100 most variable genes per cell type, can change # this number through the num_top_gene argument   #--------------------------------------------------------------------------- # cell type specific pathway expressions #--------------------------------------------------------------------------- feature_pathway_gsva <- run_pathway_gsva(data, species = \"Homo sapiens\") feature_pathway_mean <- run_pathway_mean(data, species = \"Homo sapiens\") # by default, use the 50 hallmark pathways, users can also input their gene # set of interest in a list format geneset <- list(     \"pathway_a\" = c(\"CAPNS1\", \"TLCD1\"),     \"pathway_b\" = c(\"PEX6\", \"DPRXP4\") ) feature_pathway_prop <- run_pathway_prop(   data, geneset = geneset,   species = \"Homo sapiens\" )   #--------------------------------------------------------------------------- # cell type specific cell-cell interactions #--------------------------------------------------------------------------- feature_CCI <- run_CCI(data)   #--------------------------------------------------------------------------- # Bulk expressions #---------------------------------------------------------------------------  # by default, use the top variable genes # users can change the number of top variable genes by changing `num_top_gene` # alternatively, users can also input their genes of interest in a list format feature_gene_mean_bulk <- run_gene_mean(data) feature_gene_cor_bulk <- run_gene_cor(data, num_top_gene = 5) genes_of_interest <- c(\"TIGIT\", \"PDCD1\") feature_gene_prop_bulk <- run_gene_prop(data, genes = genes_of_interest) # by default, pick 1500 most variable genes, can change this number through the # num_top_gene argument"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_summary.html","id":"scfeatures-for-spatial-proteomics","dir":"Articles","previous_headings":"","what":"scFeatures for spatial proteomics","title":"An overview of scFeatures' functions","text":"input data Seurat object containing celltype, sample, x_coord y_coord columns. SingleCellExperiment SpatialExperiment object, provide function makeSeurat() conversion. use Note , spatial proteomics contain genes, feature categories pathway expressions cell-cell interactions applicable.","code":"#--------------------------------------------------------------------------- # read in data #---------------------------------------------------------------------------  data <- readRDS(   system.file(\"extdata\", \"example_scrnaseq.rds\", package = \"scFeatures\") )  # randomly generate some x and y coordinate to make this a  # toy \"spatial proteomics\" data x <- sample(1:100, ncol(data) , replace = T) y <- sample(1:100, ncol(data) , replace = T) data <- makeSeurat(data, spatialCoords = list(x,y)) data <- process_data(data, normalise = T)    #--------------------------------------------------------------------------- # cell type proportions #--------------------------------------------------------------------------- feature_proportion_raw <- run_proportion_raw(data, type = \"spatial_p\") feature_proportion_logit <- run_proportion_logit(data, type = \"spatial_p\") feature_proportion_ratio <- run_proportion_ratio(data, type = \"spatial_p\")   #--------------------------------------------------------------------------- # cell type specific gene expressions #--------------------------------------------------------------------------- feature_gene_mean_celltype <- run_gene_mean_celltype(data, type = \"spatial_p\") feature_gene_prop_celltype <- run_gene_prop_celltype(data, type = \"spatial_p\") feature_gene_cor_celltype <- run_gene_cor_celltype(data, type = \"spatial_p\")   #--------------------------------------------------------------------------- # Bulk expressions #--------------------------------------------------------------------------- feature_gene_mean_bulk <- run_gene_mean(data, type = \"spatial_p\") feature_gene_prop_bulk <- run_gene_prop(data, type = \"spatial_p\") feature_gene_cor_bulk <- run_gene_cor(data, type = \"spatial_p\")   #--------------------------------------------------------------------------- # Spatial metrics #--------------------------------------------------------------------------- feature_L_stats <- run_L_function(data, type = \"spatial_p\") feature_morans_I <- run_Morans_I(data, type = \"spatial_p\") feature_celltype_interact <- run_celltype_interaction(data, type = \"spatial_p\") feature_nn_correlation <- run_nn_correlation(data, type = \"spatial_p\")"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_summary.html","id":"scfeature-for-spatial-transcriptomics","dir":"Articles","previous_headings":"","what":"scFeature for spatial transcriptomics","title":"An overview of scFeatures' functions","text":"input data Seurat object containing sample, x_cord y_cord columns. Additionally, apart RNA assay, contains gene expression spot, predictions assay also needed. predictions assay matrix form cell types x spot, stores cell type probability spot. can obtained performing cell type prediction using reference data.","code":"#--------------------------------------------------------------------------- # read in data #---------------------------------------------------------------------------  data <- readRDS(   system.file(\"extdata\", \"example_scrnaseq.rds\", package = \"scFeatures\") )  # generate a toy \"spatial transcriptomics\" data data$celltype <- NULL #spatial transcriptomics don't have celltype   # randomly generate some x and y coordinates x <- sample(1:100, ncol(data) , replace = T) y <- sample(1:100, ncol(data) , replace = T)  # for spatial transcriptomics, we need to estimate the number of cells per spot data <- get_num_cell_per_spot(data)  # also need a dataframe of celltype probability at each spot  # here we randomly create one  nrow <- 5 #pretend there are 5 cell types  ncol <- ncol(data)   # Create a matrix of random numbers matrix <- matrix(runif(nrow * ncol), nrow, ncol) # Normalize the columns of the matrix so that each column sum to 1 prediction.scores <-  sweep(matrix, 2, colSums(matrix), \"/\") colnames(prediction.scores) <- colnames(data) rownames(prediction.scores) <- c(paste0(\"celltype\", 1:5))  # format the data using makeSeurat data <- makeSeurat(data, spatialCoords = list(x,y), spotProbability = prediction.scores) data <- process_data(data, normalise = T)       # format the patient ID as `a_cond_b` eg, `patient09_cond_nonresponder`. # This is so that we can retrieve the sample ID and the corresponding # condition when running downstream analysis on the generated features data$sample <- paste0(data$sample, \"_cond_\", data$condition)  #--------------------------------------------------------------------------- # cell type proportions #--------------------------------------------------------------------------- feature_proportion_raw <- run_proportion_raw(data, type = \"spatial_t\") feature_proportion_logit <- run_proportion_logit(data, type = \"spatial_t\") feature_proportion_ratio <- run_proportion_ratio(data, type = \"spatial_t\")   #--------------------------------------------------------------------------- # cell type specific gene expressions #--------------------------------------------------------------------------- data_remove_mito <- remove_mito(data) feature_gene_mean_celltype <- run_gene_mean_celltype(   data_remove_mito, type = \"spatial_t\", genes = rownames(data_remove_mito)[1:10] #to speed up example )   #--------------------------------------------------------------------------- # cell type specific pathway expressions #--------------------------------------------------------------------------- feature_pathway_mean <- run_pathway_mean(data, geneset = NULL, type = \"spatial_t\")   #--------------------------------------------------------------------------- # Bulk expressions #--------------------------------------------------------------------------- feature_gene_mean_bulk <- run_gene_mean(data, type = \"spatial_t\") feature_gene_prop_bulk <- run_gene_prop(data, type = \"spatial_t\") feature_gene_cor_bulk <- run_gene_cor(data, type = \"spatial_t\")   #--------------------------------------------------------------------------- # Spatial metrics #--------------------------------------------------------------------------- feature_L_stats <- run_L_function(data, type = \"spatial_t\") feature_morans_I <- run_Morans_I(data, type = \"spatial_t\") feature_celltype_interact <- run_celltype_interaction(data, type = \"spatial_t\") feature_nn_correlation <- run_nn_correlation(data, type = \"spatial_t\")"},{"path":"https://sydneybiox.github.io/scFeatures/articles/scFeatures_summary.html","id":"sessioninfo","dir":"Articles","previous_headings":"","what":"sessionInfo()","title":"An overview of scFeatures' functions","text":"","code":"sessionInfo() #> R version 4.2.1 (2022-06-23) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Debian GNU/Linux 11 (bullseye) #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.13.so #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] scFeatures_0.99.9 BiocStyle_2.24.0  #>  #> loaded via a namespace (and not attached): #>   [1] rappdirs_0.3.3              rtracklayer_1.56.1          #>   [3] scattermore_0.8             SpatialExperiment_1.6.1     #>   [5] R.methodsS3_1.8.2           SeuratObject_4.1.2          #>   [7] ragg_1.2.3                  tidyr_1.2.1                 #>   [9] ggplot2_3.3.6               bit64_4.0.5                 #>  [11] knitr_1.40                  R.utils_2.12.0              #>  [13] irlba_2.3.5.1               DelayedArray_0.22.0         #>  [15] data.table_1.14.2           rpart_4.1.16                #>  [17] KEGGREST_1.36.3             RCurl_1.98-1.9              #>  [19] AnnotationFilter_1.20.0     generics_0.1.3              #>  [21] BiocGenerics_0.42.0         GenomicFeatures_1.48.4      #>  [23] ScaledMatrix_1.4.1          cowplot_1.1.1               #>  [25] RSQLite_2.2.18              EnsDb.Mmusculus.v79_2.99.0  #>  [27] RANN_2.6.1                  future_1.28.0               #>  [29] bit_4.0.4                   spatstat.data_3.0-0         #>  [31] xml2_1.3.3                  httpuv_1.6.6                #>  [33] SummarizedExperiment_1.26.1 assertthat_0.2.1            #>  [35] xfun_0.33                   hms_1.1.2                   #>  [37] jquerylib_0.1.4             babelgene_22.9              #>  [39] evaluate_0.17               promises_1.2.0.1            #>  [41] fansi_1.0.3                 restfulr_0.0.15             #>  [43] progress_1.2.2              caTools_1.18.2              #>  [45] dbplyr_2.2.1                igraph_1.3.5                #>  [47] DBI_1.1.3                   htmlwidgets_1.5.4           #>  [49] spatstat.geom_3.0-3         stats4_4.2.1                #>  [51] purrr_0.3.5                 ellipsis_0.3.2              #>  [53] RSpectra_0.16-1             dplyr_1.0.10                #>  [55] bookdown_0.30               annotate_1.74.0             #>  [57] RcppParallel_5.1.5          biomaRt_2.52.0              #>  [59] deldir_1.0-6                sparseMatrixStats_1.8.0     #>  [61] MatrixGenerics_1.8.1        vctrs_0.4.2                 #>  [63] SingleCellExperiment_1.18.1 Biobase_2.56.0              #>  [65] ensembldb_2.20.2            ROCR_1.0-11                 #>  [67] abind_1.4-5                 withr_2.5.0                 #>  [69] cachem_1.0.6                SIMLR_1.22.0                #>  [71] progressr_0.11.0            sctransform_0.3.5           #>  [73] GenomicAlignments_1.32.1    prettyunits_1.1.1           #>  [75] scran_1.24.1                goftest_1.2-3               #>  [77] cluster_2.1.4               ape_5.6-2                   #>  [79] lazyeval_0.2.2              crayon_1.5.2                #>  [81] spatstat.explore_3.0-5      edgeR_3.38.4                #>  [83] pkgconfig_2.0.3             GenomeInfoDb_1.32.4         #>  [85] nlme_3.1-160                ProtGenerics_1.28.0         #>  [87] rlang_1.0.6                 globals_0.16.1              #>  [89] lifecycle_1.0.3             miniUI_0.1.1.1              #>  [91] filelock_1.0.2              BiocFileCache_2.4.0         #>  [93] rsvd_1.0.5                  rprojroot_2.0.3             #>  [95] polyclip_1.10-0             GSVA_1.44.5                 #>  [97] matrixStats_0.62.0          lmtest_0.9-40               #>  [99] graph_1.74.0                Matrix_1.5-3                #> [101] Rhdf5lib_1.18.2             zoo_1.8-11                  #> [103] ggridges_0.5.4              GlobalOptions_0.1.2         #> [105] pheatmap_1.0.12             png_0.1-7                   #> [107] viridisLite_0.4.1           rjson_0.2.21                #> [109] bitops_1.0-7                R.oo_1.25.0                 #> [111] rhdf5filters_1.8.0          KernSmooth_2.23-20          #> [113] SingleCellSignalR_1.8.0     Biostrings_2.64.1           #> [115] blob_1.2.3                  DelayedMatrixStats_1.18.1   #> [117] shape_1.4.6                 stringr_1.4.1               #> [119] parallelly_1.32.1           spatstat.random_3.0-1       #> [121] S4Vectors_0.34.0            beachmat_2.12.0             #> [123] scales_1.2.1                GSEABase_1.58.0             #> [125] memoise_2.0.1               magrittr_2.0.3              #> [127] plyr_1.8.7                  ica_1.0-3                   #> [129] gplots_3.1.3                zlibbioc_1.42.0             #> [131] compiler_4.2.1              dqrng_0.3.0                 #> [133] BiocIO_1.6.0                RColorBrewer_1.1-3          #> [135] fitdistrplus_1.1-8          Rsamtools_2.12.0            #> [137] cli_3.4.1                   XVector_0.36.0              #> [139] listenv_0.8.0               EnsDb.Hsapiens.v79_2.99.0   #> [141] patchwork_1.1.2             pbapply_1.5-0               #> [143] MASS_7.3-58.1               mgcv_1.8-40                 #> [145] tidyselect_1.2.0            stringi_1.7.8               #> [147] textshaping_0.3.6           yaml_2.3.5                  #> [149] BiocSingular_1.12.0         locfit_1.5-9.6              #> [151] ggrepel_0.9.1               grid_4.2.1                  #> [153] sass_0.4.2                  tools_4.2.1                 #> [155] future.apply_1.9.1          parallel_4.2.1              #> [157] circlize_0.4.15             rstudioapi_0.14             #> [159] foreach_1.5.2               bluster_1.6.0               #> [161] AUCell_1.18.1               metapod_1.4.0               #> [163] gridExtra_2.3               Rtsne_0.16                  #> [165] DropletUtils_1.16.0         proxyC_0.3.3                #> [167] digest_0.6.29               BiocManager_1.30.18         #> [169] rgeos_0.5-9                 shiny_1.7.2                 #> [171] pracma_2.4.2                Rcpp_1.0.9                  #> [173] GenomicRanges_1.48.0        scuttle_1.6.3               #> [175] later_1.3.0                 RcppAnnoy_0.0.19            #> [177] httr_1.4.4                  AnnotationDbi_1.58.0        #> [179] colorspace_2.0-3            XML_3.99-0.11               #> [181] fs_1.5.2                    tensor_1.5                  #> [183] reticulate_1.26             IRanges_2.30.1              #> [185] splines_4.2.1               uwot_0.1.14                 #> [187] statmod_1.4.37              spatstat.utils_3.0-1        #> [189] pkgdown_2.0.6               sp_1.5-0                    #> [191] multtest_2.52.0             plotly_4.10.0               #> [193] systemfonts_1.0.4           xtable_1.8-4                #> [195] jsonlite_1.8.2              R6_2.5.1                    #> [197] pillar_1.8.1                htmltools_0.5.3             #> [199] mime_0.12                   glue_1.6.2                  #> [201] fastmap_1.1.0               BiocParallel_1.30.4         #> [203] BiocNeighbors_1.14.0        codetools_0.2-18            #> [205] utf8_1.2.2                  lattice_0.20-45             #> [207] bslib_0.4.0                 spatstat.sparse_3.0-0       #> [209] tibble_3.1.8                curl_4.3.3                  #> [211] leiden_0.4.3                gtools_3.9.3                #> [213] magick_2.7.3                survival_3.4-0              #> [215] limma_3.52.4                rmarkdown_2.17              #> [217] desc_1.4.2                  munsell_0.5.0               #> [219] rhdf5_2.40.0                GenomeInfoDbData_1.2.8      #> [221] iterators_1.0.14            HDF5Array_1.24.2            #> [223] msigdbr_7.5.1               reshape2_1.4.4              #> [225] gtable_0.3.1                spatstat.core_2.4-4         #> [227] Seurat_4.2.0"},{"path":"https://sydneybiox.github.io/scFeatures/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Yue Cao. Author, maintainer. Yingxin Lin. Author. Ellis Patrick. Author. Pengyi Yang. Author. Jean Yee Hwa Yang. Author.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Cao,Y.,Lin,Y.,Patrick,E.,Yang,P.,&Yang,J.Y.H.(2022). scFeatures: Multi-view representations single-cell spatial data disease outcome prediction. Bioinformatics, Volume 38, Issue 20, 15 October 2022, Pages 4745-4753.","code":"@Article{,   title = {scFeatures: multi-view representations of single-cell and spatial data for disease outcome prediction},   journal = {Bioinformatics},   author = {{Cao,Y.} and {Lin,Y.} and {Patrick,E.} and {Yang,P.} and & Yang,J.Y.H.},   volume = {38},   number = {20},   pages = {4745-4753},   year = {2022},   month = {08},   issn = {1367-4803},   doi = {10.1093/bioinformatics/btac590},   url = {https://doi.org/10.1093/bioinformatics/btac590},   eprint = {https://academic.oup.com/bioinformatics/article-pdf/38/20/4745/46535070/btac590.pdf}, }"},{"path":"https://sydneybiox.github.io/scFeatures/index.html","id":"scfeatures-multi-view-representations-of-single-cell-and-spatial-data-for-disease-outcome-prediction","dir":"","previous_headings":"","what":"scFeatures: Multi-view representations of single-cell and spatial data\n       for disease outcome prediction","title":"scFeatures: Multi-view representations of single-cell and spatial data\n       for disease outcome prediction","text":"scFeatures tool generates multi-view representations single-cell spatial data construction total 17 feature types belonging following six categories. cell type proportions cell type specific gene expressions cell type specific pathway expressions cell type specific cell-cell interaction (CCI) scores overall aggregated gene expressions spatial metrics","code":""},{"path":"https://sydneybiox.github.io/scFeatures/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"scFeatures: Multi-view representations of single-cell and spatial data\n       for disease outcome prediction","text":"latest scFeatures can installed using devtools:","code":"library(devtools) devtools::install_github(\"SydneyBioX/scFeatures\")"},{"path":"https://sydneybiox.github.io/scFeatures/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"scFeatures: Multi-view representations of single-cell and spatial data\n       for disease outcome prediction","text":"Please see https://sydneybiox.github.io/scFeatures/articles/scFeatures_overview.html.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/index.html","id":"reference","dir":"","previous_headings":"","what":"Reference","title":"scFeatures: Multi-view representations of single-cell and spatial data\n       for disease outcome prediction","text":"Cao, Y., Lin, Y., Patrick, E., Yang, P., & Yang, J. Y. H. (2022). scFeatures: multi-view representations single-cell spatial data disease outcome prediction. O. Vitek (Ed.), Bioinformatics (Vol. 38, Issue 20, pp. 4745–4753). Oxford University Press (OUP). https://doi.org/10.1093/bioinformatics/btac590","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/example_scrnaseq.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of scRNA-seq data — example_scrnaseq","title":"Example of scRNA-seq data — example_scrnaseq","text":"subsampled version melanoma patients dataset used manuscript. original dataset available : https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE120575.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/example_scrnaseq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of scRNA-seq data — example_scrnaseq","text":"","code":"data(\"example_scrnaseq\")"},{"path":[]},{"path":"https://sydneybiox.github.io/scFeatures/reference/example_scrnaseq.html","id":"example-scrnaseq","dir":"Reference","previous_headings":"","what":"example_scrnaseq","title":"Example of scRNA-seq data — example_scrnaseq","text":"Seurat object 3523 genes 550 cells. key metadata columns : celltype cell type cell sample patient ID cell condition whether patient responder non-responder","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/example_scrnaseq.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example of scRNA-seq data — example_scrnaseq","text":"https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE120575","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/get_num_cell_per_spot.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate a relative number of cells per spot for\nspatial transcriptomics data — get_num_cell_per_spot","title":"Estimate a relative number of cells per spot for\nspatial transcriptomics data — get_num_cell_per_spot","text":"function takes list object containing spatial transcriptomics matrix input estimates relative number cells per spot data. number cells estimated library size scaled range 1 100. value stored number_cells attribute.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/get_num_cell_per_spot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate a relative number of cells per spot for\nspatial transcriptomics data — get_num_cell_per_spot","text":"","code":"get_num_cell_per_spot(alldata)"},{"path":"https://sydneybiox.github.io/scFeatures/reference/get_num_cell_per_spot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate a relative number of cells per spot for\nspatial transcriptomics data — get_num_cell_per_spot","text":"alldata list object containing spatial transcriptomics","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/get_num_cell_per_spot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate a relative number of cells per spot for\nspatial transcriptomics data — get_num_cell_per_spot","text":"vector relative number cells spot.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/get_num_cell_per_spot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate a relative number of cells per spot for\nspatial transcriptomics data — get_num_cell_per_spot","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq #> Loading required package: SeuratObject #> Loading required package: sp #>  #> Attaching package: 'SeuratObject' #> The following object is masked from 'package:base': #>  #>     intersect data$celltype <- NULL  number_of_cells <- get_num_cell_per_spot(data) #> Error in (function (cond) .Internal(C_tryCatchHelper(addr, 1L, cond)))(structure(list(message = \"'data' not found in this Seurat object\\n \",     trace = structure(list(call = list(tryCatch(withCallingHandlers({        NULL        saveRDS(do.call(do.call, c(readRDS(\"/tmp/RtmpFLcHLZ/callr-fun-19964b627c11b3\"),             list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv,             quote = TRUE), file = \"/tmp/RtmpFLcHLZ/callr-res-19964b4b6463\",             compress = FALSE)        flush(stdout())        flush(stderr())        NULL        invisible()    }, error = function(e) {        {            callr_data <- as.environment(\"tools:callr\")$`__callr_data__`            err <- callr_data$err            if (FALSE) {                assign(\".Traceback\", .traceback(4), envir = callr_data)                dump.frames(\"__callr_dump__\")                assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`,                   envir = callr_data)                rm(\"__callr_dump__\", envir = .GlobalEnv)            }            e <- err$process_call(e)            e2 <- err$new_error(\"error in callr subprocess\")            class(e2) <- c(\"callr_remote_error\", class(e2))            e2 <- err$add_trace_back(e2)            cut <- which(e2$trace$scope == \"global\")[1]            if (!is.na(cut)) {                e2$trace <- e2$trace[-(1:cut), ]            }            saveRDS(list(\"error\", e2, e), file = paste0(\"/tmp/RtmpFLcHLZ/callr-res-19964b4b6463\",                 \".error\"))        }    }, interrupt = function(e) {        {            callr_data <- as.environment(\"tools:callr\")$`__callr_data__`            err <- callr_data$err            if (FALSE) {                assign(\".Traceback\", .traceback(4), envir = callr_data)                dump.frames(\"__callr_dump__\")                assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`,                   envir = callr_data)                rm(\"__callr_dump__\", envir = .GlobalEnv)            }            e <- err$process_call(e)            e2 <- err$new_error(\"error in callr subprocess\")            class(e2) <- c(\"callr_remote_error\", class(e2))            e2 <- err$add_trace_back(e2)            cut <- which(e2$trace$scope == \"global\")[1]            if (!is.na(cut)) {                e2$trace <- e2$trace[-(1:cut), ]            }            saveRDS(list(\"error\", e2, e), file = paste0(\"/tmp/RtmpFLcHLZ/callr-res-19964b4b6463\",                 \".error\"))        }    }, callr_message = function(e) {        try(signalCondition(e))    }), error = function(e) {        NULL        if (FALSE) {            try(stop(e))        }        else {            invisible()        }    }, interrupt = function(e) {        NULL        if (FALSE) {            e        }        else {            invisible()        }    }), tryCatchList(expr, classes, parentenv, handlers), tryCatchOne(tryCatchList(expr,         names[-nh], parentenv, handlers[-nh]), names[nh], parentenv,         handlers[[nh]]), doTryCatch(return(expr), name, parentenv,         handler), tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),         tryCatchOne(expr, names, parentenv, handlers[[1L]]),         doTryCatch(return(expr), name, parentenv, handler), withCallingHandlers({            NULL            saveRDS(do.call(do.call, c(readRDS(\"/tmp/RtmpFLcHLZ/callr-fun-19964b627c11b3\"),                 list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv,                 quote = TRUE), file = \"/tmp/RtmpFLcHLZ/callr-res-19964b4b6463\",                 compress = FALSE)            flush(stdout())            flush(stderr())            NULL            invisible()        }, error = function(e) {            {                callr_data <- as.environment(\"tools:callr\")$`__callr_data__`                err <- callr_data$err                if (FALSE) {                  assign(\".Traceback\", .traceback(4), envir = callr_data)                  dump.frames(\"__callr_dump__\")                  assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`,                     envir = callr_data)                  rm(\"__callr_dump__\", envir = .GlobalEnv)                }                e <- err$process_call(e)                e2 <- err$new_error(\"error in callr subprocess\")                class(e2) <- c(\"callr_remote_error\", class(e2))                e2 <- err$add_trace_back(e2)                cut <- which(e2$trace$scope == \"global\")[1]                if (!is.na(cut)) {                  e2$trace <- e2$trace[-(1:cut), ]                }                saveRDS(list(\"error\", e2, e), file = paste0(\"/tmp/RtmpFLcHLZ/callr-res-19964b4b6463\",                   \".error\"))            }        }, interrupt = function(e) {            {                callr_data <- as.environment(\"tools:callr\")$`__callr_data__`                err <- callr_data$err                if (FALSE) {                  assign(\".Traceback\", .traceback(4), envir = callr_data)                  dump.frames(\"__callr_dump__\")                  assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`,                     envir = callr_data)                  rm(\"__callr_dump__\", envir = .GlobalEnv)                }                e <- err$process_call(e)                e2 <- err$new_error(\"error in callr subprocess\")                class(e2) <- c(\"callr_remote_error\", class(e2))                e2 <- err$add_trace_back(e2)                cut <- which(e2$trace$scope == \"global\")[1]                if (!is.na(cut)) {                  e2$trace <- e2$trace[-(1:cut), ]                }                saveRDS(list(\"error\", e2, e), file = paste0(\"/tmp/RtmpFLcHLZ/callr-res-19964b4b6463\",                   \".error\"))            }        }, callr_message = function(e) {            try(signalCondition(e))        }), saveRDS(do.call(do.call, c(readRDS(\"/tmp/RtmpFLcHLZ/callr-fun-19964b627c11b3\"),             list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv,             quote = TRUE), file = \"/tmp/RtmpFLcHLZ/callr-res-19964b4b6463\",             compress = FALSE), do.call(do.call, c(readRDS(\"/tmp/RtmpFLcHLZ/callr-fun-19964b627c11b3\"),             list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv,             quote = TRUE), `<fn>`(base::quote(`<fn>`), base::quote(`<named list>`),             envir = base::quote(`<env>`), quote = base::quote(TRUE)),         `<fn>`(pkg = base::quote(`<pkgdown>`), examples = base::quote(TRUE),             run_dont_run = base::quote(FALSE), seed = base::quote(1014),             lazy = base::quote(FALSE), override = base::quote(`<list>`),             install = base::quote(FALSE), preview = base::quote(FALSE),             new_process = base::quote(FALSE), devel = base::quote(FALSE),             cli_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE)),         pkgdown::build_site(...), build_site_local(pkg = pkg,             examples = examples, run_dont_run = run_dont_run,             seed = seed, lazy = lazy, override = override, preview = preview,             devel = devel), build_reference(pkg, lazy = lazy,             examples = examples, run_dont_run = run_dont_run,             seed = seed, override = override, preview = FALSE,             devel = devel), purrr::map(topics, build_reference_topic,             pkg = pkg, lazy = lazy, examples_env = examples_env,             run_dont_run = run_dont_run), map_(\"list\", .x, .f,             ..., .progress = .progress), with_indexed_errors(i = i,             names = names, error_call = .purrr_error_call, call_with_cleanup(map_impl,                 environment(), .type, .progress, n, names, i)),         withCallingHandlers(expr, error = function(cnd) {            if (i == 0L) {            }            else {                message <- c(i = \"In index: {i}.\")                if (!is.null(names) && !is.na(names[[i]]) &&                   names[[i]] != \"\") {                  name <- names[[i]]                  message <- c(message, i = \"With name: {name}.\")                }                else {                  name <- NULL                }                cli::cli_abort(message, location = i, name = name,                   parent = cnd, call = error_call, class = \"purrr_error_indexed\")            }        }), call_with_cleanup(map_impl, environment(), .type,             .progress, n, names, i), .f(.x[[i]], ...), withCallingHandlers(data_reference_topic(topic,             pkg, examples_env = examples_env, run_dont_run = run_dont_run),             error = function(err) {                msg <- c(paste0(\"Failed to parse Rd in \", topic$file_in),                   i = err$message)                abort(msg, parent = err)            }), data_reference_topic(topic, pkg, examples_env = examples_env,             run_dont_run = run_dont_run), run_examples(tags$tag_examples[[1]],             env = if (is.null(examples_env)) NULL else new.env(parent = examples_env),             topic = tools::file_path_sans_ext(topic$file_in),             run_dont_run = run_dont_run), highlight_examples(code,             topic, env = env), downlit::evaluate_and_highlight(code,             fig_save = fig_save_topic, env = child_env(env),             output_handler = evaluate::new_output_handler(value = pkgdown_print)),         evaluate::evaluate(code, child_env(env), new_device = TRUE,             output_handler = output_handler), evaluate_call(expr,             parsed$src[[i]], envir = envir, enclos = enclos,             debug = debug, last = i == length(out), use_try = stop_on_error !=                 2L, keep_warning = keep_warning, keep_message = keep_message,             log_echo = log_echo, log_warning = log_warning, output_handler = output_handler,             include_timing = include_timing), timing_fn(handle(ev <- withCallingHandlers(withVisible(eval_with_user_handlers(expr,             envir, enclos, user_handlers)), warning = wHandler,             error = eHandler, message = mHandler))), handle(ev <- withCallingHandlers(withVisible(eval_with_user_handlers(expr,             envir, enclos, user_handlers)), warning = wHandler,             error = eHandler, message = mHandler)), try(f, silent = TRUE),         tryCatch(expr, error = function(e) {            call <- conditionCall(e)            if (!is.null(call)) {                if (identical(call[[1L]], quote(doTryCatch)))                   call <- sys.call(-4L)                dcall <- deparse(call, nlines = 1L)                prefix <- paste(\"Error in\", dcall, \": \")                LONG <- 75L                sm <- strsplit(conditionMessage(e), \"\\n\")[[1L]]                w <- 14L + nchar(dcall, type = \"w\") + nchar(sm[1L],                   type = \"w\")                if (is.na(w))                   w <- 14L + nchar(dcall, type = \"b\") + nchar(sm[1L],                     type = \"b\")                if (w > LONG)                   prefix <- paste0(prefix, \"\\n  \")            }            else prefix <- \"Error : \"            msg <- paste0(prefix, conditionMessage(e), \"\\n\")            .Internal(seterrmessage(msg[1L]))            if (!silent && isTRUE(getOption(\"show.error.messages\"))) {                cat(msg, file = outFile)                .Internal(printDeferredWarnings())            }            invisible(structure(msg, class = \"try-error\", condition = e))        }), tryCatchList(expr, classes, parentenv, handlers),         tryCatchOne(expr, names, parentenv, handlers[[1L]]),         doTryCatch(return(expr), name, parentenv, handler), withCallingHandlers(withVisible(eval_with_user_handlers(expr,             envir, enclos, user_handlers)), warning = wHandler,             error = eHandler, message = mHandler), withVisible(eval_with_user_handlers(expr,             envir, enclos, user_handlers)), eval_with_user_handlers(expr,             envir, enclos, user_handlers), eval(expr, envir,             enclos), eval(expr, envir, enclos), get_num_cell_per_spot(data),         colSums(alldata$data), alldata$data, `$.Seurat`(alldata,             \"data\"), x[[i, drop = TRUE]], `[[.Seurat`(x, i, drop = TRUE),         tryCatch(expr = arg_match(arg = i, values = meta.cols,             multiple = TRUE), error = function(e) {            abort(message = paste(paste(sQuote(x = setdiff(x = i,                 y = meta.cols)), collapse = \", \"), \"not found in this Seurat object\\n\",                 e$body), call = rlang::caller_env(n = 4L))        }), tryCatchList(expr, classes, parentenv, handlers),         tryCatchOne(expr, names, parentenv, handlers[[1L]]),         value[[3L]](cond), abort(message = paste(paste(sQuote(x = setdiff(x = i,             y = meta.cols)), collapse = \", \"), \"not found in this Seurat object\\n\",             e$body), call = rlang::caller_env(n = 4L))), parent = c(0L,     1L, 2L, 3L, 2L, 5L, 6L, 0L, 0L, 0L, 0L, 0L, 12L, 13L, 14L,     15L, 16L, 17L, 18L, 17L, 17L, 21L, 21L, 23L, 24L, 25L, 26L,     27L, 28L, 28L, 30L, 31L, 32L, 33L, 34L, 28L, 28L, 28L, 38L,     39L, 40L, 41L, 41L, 41L, 44L, 44L, 46L, 47L, 48L, 49L, 50L    ), visible = c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE,     TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE,     TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE,     TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE,     TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE,     FALSE, FALSE, FALSE, FALSE), namespace = c(\"base\", \"base\",     \"base\", \"base\", \"base\", \"base\", \"base\", \"base\", \"base\", \"base\",     \"base\", NA, \"pkgdown\", \"pkgdown\", \"pkgdown\", \"purrr\", \"purrr\",     \"purrr\", \"base\", \"purrr\", \"pkgdown\", \"base\", \"pkgdown\", \"pkgdown\",     \"pkgdown\", \"downlit\", \"evaluate\", \"evaluate\", \"evaluate\",     \"evaluate\", \"base\", \"base\", \"base\", \"base\", \"base\", \"base\",     \"base\", \"evaluate\", \"base\", \"base\", \"scFeatures\", \"methods\",     NA, \"SeuratObject\", NA, \"SeuratObject\", \"base\", \"base\", \"base\",     NA, \"rlang\"), scope = c(\"::\", \"local\", \"local\", \"local\",     \"local\", \"local\", \"local\", \"::\", \"::\", \"::\", \"local\", \"global\",     \"::\", \":::\", \"::\", \"::\", \":::\", \":::\", \"::\", \":::\", \"local\",     \"::\", \":::\", \":::\", \":::\", \"::\", \"::\", \":::\", \"local\", \"local\",     \"::\", \"::\", \"local\", \"local\", \"local\", \"::\", \"::\", \":::\",     \"::\", \"::\", \"::\", \"local\", NA, \":::\", NA, \":::\", \"::\", \"local\",     \"local\", NA, \"::\"), error_frame = c(FALSE, FALSE, FALSE,     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE,     FALSE, FALSE, FALSE)), row.names = c(NA, -51L), version = 2L, class = c(\"rlang_trace\",     \"rlib_trace\", \"tbl\", \"data.frame\")), parent = NULL, rlang = list(        inherit = TRUE), call = x[[i, drop = TRUE]]), class = c(\"rlang_error\", \"error\", \"condition\"))): error in evaluating the argument 'x' in selecting a method for function 'colSums': 'data' not found in this Seurat object #>"},{"path":"https://sydneybiox.github.io/scFeatures/reference/makeSeurat.html","id":null,"dir":"Reference","previous_headings":"","what":"Format data into Seurat object structured for scFeatures functions — makeSeurat","title":"Format data into Seurat object structured for scFeatures functions — makeSeurat","text":"function used convert SingleCellExperiment, SpatialExperiment Seurat object Seurat object containing required fields structured scFeatures functions.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/makeSeurat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format data into Seurat object structured for scFeatures functions — makeSeurat","text":"","code":"makeSeurat(   data,   sample = NULL,   celltype = NULL,   assay = NULL,   spatialCoords = NULL,   spotProbability = NULL )"},{"path":"https://sydneybiox.github.io/scFeatures/reference/makeSeurat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format data into Seurat object structured for scFeatures functions — makeSeurat","text":"data input data, either SingleCellExperiment SpatialExperiment object. object needs contain column named \"sample\" column named \"celltype\". Alternatively, user can provide name column containing sample celltype sample celltype argument. passing SingleCellExperiment SpatialExperiment, default use assay stored \"logcount\". Alternatively, user can specify assay use assay argument. users want construct features spatial category, default need columns called \"x_cord\" \"y_cord\". Alternatively, please specify relevant column spatialCoords argument. spot-based spatial transcriptomics, also requires matrix containing cell type prediction probability spot, format celltype x spot sample vector providing sample identifier cell. provided, assume data contain metadata column \"sample\" running scFeatures. celltype vector providing celltype identifier. provided, assume data contain metadata column \"celltype\" running scFeatures. assay assay identifier using SingleCellExperiment SpatialExperiment object. spatialCoords spatialCoords identifiers provided list two vectors, users want construct features spatial category. provided, assume data contain metadata columns \"x_cord\" \"y_cord\" constructing spatial features. spotProbability matrix format celltype x spot, entry prediction probability cell type spot. needed spatial transcriptomics data.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/makeSeurat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format data into Seurat object structured for scFeatures functions — makeSeurat","text":"Seurat dataset containing required metadata running scFeatures.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/makeSeurat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format data into Seurat object structured for scFeatures functions — makeSeurat","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\")  data <- example_scrnaseq  coordinate <- list(x = rep(1, ncol(data)), y = rep(1, ncol(data)))  data <- makeSeurat(data, spatialCoords = coordinate)"},{"path":"https://sydneybiox.github.io/scFeatures/reference/process_data.html","id":null,"dir":"Reference","previous_headings":"","what":"data pre-processing — process_data","title":"data pre-processing — process_data","text":"function takes Seurat object input data cleaning pre-processing. example, replaces \"+\" \"-\" signs celltype column \"plus\" \"minus\", respectively. also removes patients less 10 cells across cell types. normalise argument set TRUE, function normalize data using Seurat::NormalizeData function.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/process_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"data pre-processing — process_data","text":"","code":"process_data(data, normalise = TRUE)"},{"path":"https://sydneybiox.github.io/scFeatures/reference/process_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"data pre-processing — process_data","text":"data input data, Seurat object. normalise logical value indicating whether normalize data . Default value TRUE.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/process_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"data pre-processing — process_data","text":"Seurat object","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/process_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"data pre-processing — process_data","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq data <- process_data(data, normalise = FALSE)"},{"path":"https://sydneybiox.github.io/scFeatures/reference/remove_mito.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove mitochondrial and ribosomal genes, and other highly correlated genes — remove_mito","title":"Remove mitochondrial and ribosomal genes, and other highly correlated genes — remove_mito","text":"function removes mitochondria ribosomal genes genes highly correlated genes, mitochondria ribosomal genes typically  interesting look .","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/remove_mito.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove mitochondrial and ribosomal genes, and other highly correlated genes — remove_mito","text":"","code":"remove_mito(data)"},{"path":"https://sydneybiox.github.io/scFeatures/reference/remove_mito.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove mitochondrial and ribosomal genes, and other highly correlated genes — remove_mito","text":"data Seurat object containing expression data","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/remove_mito.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove mitochondrial and ribosomal genes, and other highly correlated genes — remove_mito","text":"Seurat object mito rib genes highly correlated genes removed","code":""},{"path":[]},{"path":"https://sydneybiox.github.io/scFeatures/reference/remove_mito_ribo.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove mitochondrial and ribosomal genes, and other highly correlated genes — remove_mito_ribo","title":"Remove mitochondrial and ribosomal genes, and other highly correlated genes — remove_mito_ribo","text":"function removes mitochondria ribosomal genes genes highly correlated genes, mitochondria ribosomal genes typically  interesting look .","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/remove_mito_ribo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove mitochondrial and ribosomal genes, and other highly correlated genes — remove_mito_ribo","text":"","code":"remove_mito_ribo(alldata)"},{"path":"https://sydneybiox.github.io/scFeatures/reference/remove_mito_ribo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove mitochondrial and ribosomal genes, and other highly correlated genes — remove_mito_ribo","text":"data list object containing expression data","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/remove_mito_ribo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove mitochondrial and ribosomal genes, and other highly correlated genes — remove_mito_ribo","text":"list object mitochrondrial ribosomal genes highly correlated genes removed","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/remove_mito_ribo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove mitochondrial and ribosomal genes, and other highly correlated genes — remove_mito_ribo","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq[, 1:20]  data <- remove_mito_ribo(data) #> Error in x[[i, drop = TRUE]]: 'data' not found in this Seurat object #>"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_CCI.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate cell cell communication score — run_CCI","title":"Generate cell cell communication score — run_CCI","text":"function calculates ligand receptor interaction score using SingleCellSignalR. output features form celltype -> celltype b -- ligand 1 -> receptor 2 , indicates interaction ligand 1 celltype receptor 2 celltype b. supports scRNA-seq.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_CCI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate cell cell communication score — run_CCI","text":"","code":"run_CCI(data, type = \"scrna\", ncores = 1)"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_CCI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate cell cell communication score — run_CCI","text":"data list object containing data matrix celltype sample vector. type input data type, either scrna, spatial_p, spatial_t ncores number cores","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_CCI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate cell cell communication score — run_CCI","text":"matrix samples x features features form ligand 1 receptor 2 celltype , ligand 1 receptor 2 celltype b ... etc, numbers representing cell-cell interaction probability.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_CCI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate cell cell communication score — run_CCI","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq[1:50, 1:20] celltype <- data$celltype sample <- data$sample data <- data@assays$RNA@data  alldata <- list(data = data, celltype = celltype, sample = sample ) feature_CCI <- run_CCI(alldata, type = \"scrna\" ,  ncores = 1 ) #> Error: BiocParallel errors #>   1 remote errors, element index: 3 #>   10 unevaluated and other errors #>   first remote error: #> Error in as.data.frame.default(x[[i]], optional = TRUE): cannot coerce class 'structure(\"dgCMatrix\", package = \"Matrix\")' to a data.frame"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_L_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate L stats — run_L_function","title":"Generate L stats — run_L_function","text":"function calculates L-statistics measure spatial autocorrelation. L value greater zero indicates spatial attraction pair proteins whereas L value less zero indicates spatial repulsion. function supports  spatial proteomics spatial transcriptomics.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_L_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate L stats — run_L_function","text":"","code":"run_L_function(data, type = \"spatial_p\", ncores = 1)"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_L_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate L stats — run_L_function","text":"data list object containing data matrix celltype sample vector. type type dataset, either \"scrna\", \"spatial_t\", \"spatial_p\". ncores Number cores parallel processing.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_L_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate L stats — run_L_function","text":"dataframe samples x features features form protein 1 vs protein 2, protein 1 vs protein 3 ... etc, numbers representing L values.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_L_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate L stats — run_L_function","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") celltype <- example_scrnaseq$celltype  data <- example_scrnaseq@assays$RNA@data sample <- sample( c(\"patient1\", \"patient2\", \"patient3\"), ncol(data) , replace= TRUE ) x <- sample(1:100, ncol(data) , replace = TRUE) y <- sample(1:100, ncol(data) , replace = TRUE) spatialCoords <- list( x , y) alldata <- list(data = data, sample = sample, celltype = celltype,  spatialCoords  = spatialCoords )  feature_L_function <- run_L_function(alldata, type = \"spatial_p\", ncores = 1) #> Error in check_data(data, type): Please ensure the data contain x_cord and y_cord."},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_Morans_I.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Moran's I — run_Morans_I","title":"Generate Moran's I — run_Morans_I","text":"function calculates Moran's measure spatial autocorrelation, indicattion strongly feature(ie, genes/proteins) expression values sample cluster disperse. value closer 1 indicates clustering similar values value closer -1 indicates clustering dissimilar values. value 0 indicates particular clustering structure, ie, values spatially distributed randomly. function supports spatial proteomics spatial transcriptomics.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_Morans_I.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Moran's I — run_Morans_I","text":"","code":"run_Morans_I(data, type = \"spatial_p\", ncores = 1)"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_Morans_I.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Moran's I — run_Morans_I","text":"data list object containing data matrix celltype sample vector. type type dataset, either \"scrna\", \"spatial_t\", \"spatial_p\". ncores Number cores parallel processing.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_Morans_I.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Moran's I — run_Morans_I","text":"dataframe samples x features features form protein 1, protein 2 ... etc, numbers representing Moran's value.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_Morans_I.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Moran's I — run_Morans_I","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq[1:50, 1:20] celltype <- data$celltype  data <- data@assays$RNA@data sample <- sample( c(\"patient1\", \"patient2\", \"patient3\"), ncol(data) , replace= TRUE ) x <- sample(1:100, ncol(data) , replace = TRUE) y <- sample(1:100, ncol(data) , replace = TRUE) spatialCoords <- list( x , y) alldata <- list(data = data, sample = sample, celltype = celltype,  spatialCoords  = spatialCoords )  feature_Morans_I <- run_Morans_I(alldata, type = \"spatial_p\", ncores = 1) #> Error in check_data(data, type): Please ensure the data contain x_cord and y_cord."},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_association_study_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an association study report in HTML format — run_association_study_report","title":"Create an association study report in HTML format — run_association_study_report","text":"function takes feature matrix generated scFeatures input creates HTML report containing results association study. report saved specified output folder.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_association_study_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an association study report in HTML format — run_association_study_report","text":"","code":"run_association_study_report(scfeatures_result, output_folder)"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_association_study_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an association study report in HTML format — run_association_study_report","text":"scfeatures_result named list storing scFeatures feature output. Note names list one multiple following: proportion_raw, proportion_logit, proportion_ratio, gene_mean_celltype, gene_prop_celltype, gene_cor_celltype, pathway_gsva, pathway_mean, pathway_prop, CCI, gene_mean_aggregated, gene_cor_aggregated, gene_prop_aggregated. output_folder path folder HTML report saved","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_association_study_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an association study report in HTML format — run_association_study_report","text":"HTML file, saved directory defined output_folder argument","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_association_study_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an association study report in HTML format — run_association_study_report","text":"","code":"output_folder <- tempdir() data(\"scfeatures_result\" , package = \"scFeatures\") run_association_study_report(scfeatures_result, output_folder ) #>  #>  #> processing file: output_report.Rmd #> 1/89                    #> 2/89 [unnamed-chunk-1]  #> 3/89                    #> 4/89 [unnamed-chunk-2]  #> 5/89                    #> 6/89 [unnamed-chunk-3]  #> 7/89                    #> 8/89 [unnamed-chunk-4]  #> 9/89                    #> 10/89 [unnamed-chunk-5]  #> 11/89                    #> 12/89 [unnamed-chunk-6]  #> 13/89                    #> 14/89 [unnamed-chunk-7]  #> 15/89                    #> 16/89 [unnamed-chunk-8]  #> 17/89                    #> 18/89 [unnamed-chunk-9]  #> 19/89                    #> 20/89 [unnamed-chunk-10] #> 21/89                    #> 22/89 [unnamed-chunk-11] #> 23/89                    #> 24/89 [unnamed-chunk-12] #> 25/89                    #> 26/89 [unnamed-chunk-13] #> 27/89                    #> 28/89 [unnamed-chunk-14] #> 29/89                    #> 30/89 [unnamed-chunk-15] #> 31/89                    #> 32/89 [unnamed-chunk-16] #> 33/89                    #> 34/89 [unnamed-chunk-17] #> 35/89                    #> 36/89 [unnamed-chunk-18] #> 37/89                    #> 38/89 [unnamed-chunk-19] #> 39/89                    #> 40/89 [unnamed-chunk-20] #> 41/89                    #> 42/89 [unnamed-chunk-21] #> 43/89                    #> 44/89 [unnamed-chunk-22] #> 45/89                    #> 46/89 [unnamed-chunk-23] #> 47/89                    #> 48/89 [unnamed-chunk-24] #> 49/89                    #> 50/89 [unnamed-chunk-25] #> 51/89                    #> 52/89 [unnamed-chunk-26] #> 53/89                    #> 54/89 [unnamed-chunk-27] #> 55/89                    #> 56/89 [unnamed-chunk-28] #> 57/89                    #> 58/89 [unnamed-chunk-29] #> 59/89                    #> 60/89 [unnamed-chunk-30] #> 61/89                    #> 62/89 [unnamed-chunk-31] #> 63/89                    #> 64/89 [unnamed-chunk-32] #> 65/89                    #> 66/89 [unnamed-chunk-33] #> 67/89                    #> 68/89 [unnamed-chunk-34] #> 69/89                    #> 70/89 [unnamed-chunk-35] #> 71/89                    #> 72/89 [unnamed-chunk-36] #> 73/89                    #> 74/89 [unnamed-chunk-37] #> 75/89                    #> 76/89 [unnamed-chunk-38] #> 77/89                    #> 78/89 [unnamed-chunk-39] #> 79/89                    #> 80/89 [unnamed-chunk-40] #> 81/89                    #> 82/89 [unnamed-chunk-41] #> 83/89                    #> 84/89 [unnamed-chunk-42] #> 85/89                    #> 86/89 [unnamed-chunk-43] #> 87/89                    #> 88/89 [unnamed-chunk-44] #> 89/89                    #> output file: output_report.knit.md #> /usr/lib/rstudio-server/bin/quarto/bin/tools/pandoc +RTS -K512m -RTS output_report.knit.md --to html4 --from markdown+autolink_bare_uris+tex_math_single_backslash --output /tmp/Rtmp8lCZn5/output_report.html --lua-filter /dora/nobackup/yuec/R/rmarkdown/rmarkdown/lua/pagebreak.lua --lua-filter /dora/nobackup/yuec/R/rmarkdown/rmarkdown/lua/latex-div.lua --embed-resources --standalone --variable bs3=TRUE --section-divs --table-of-contents --toc-depth 3 --variable toc_float=1 --variable toc_selectors=h1,h2,h3 --variable toc_collapsed=1 --variable toc_print=1 --template /dora/nobackup/yuec/R/rmarkdown/rmd/h/default.html --no-highlight --variable highlightjs=1 --number-sections --variable theme=bootstrap --mathjax --variable 'mathjax-url=https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML' --include-in-header /tmp/Rtmp8lCZn5/rmarkdown-str2af90e7857bb40.html --variable code_folding=hide --variable code_menu=1  #>  #> Output created: /tmp/Rtmp8lCZn5/output_report.html"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_celltype_interaction.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate cell type interaction — run_celltype_interaction","title":"Generate cell type interaction — run_celltype_interaction","text":"function calculates pairwise distance cell types sample using coordinates cell types cells. find nearest neighbours cell cell types neighbours. considered spatial interaction pairs. cell type composition spatial interaction pairs used features. function supports spatial proteomics spatial transcriptomics.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_celltype_interaction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate cell type interaction — run_celltype_interaction","text":"","code":"run_celltype_interaction(data, type = \"spatial_p\", ncores = 1)"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_celltype_interaction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate cell type interaction — run_celltype_interaction","text":"data list object containing data matrix celltype sample vector. type type dataset, either \"scrna\", \"spatial_t\", \"spatial_p\". ncores Number cores parallel processing.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_celltype_interaction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate cell type interaction — run_celltype_interaction","text":"dataframe samples x features features form protein 1 vs protein 2, protein 1 vs protein 3 ... etc, numbers representing proportion interaction pairs give sample.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_celltype_interaction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate cell type interaction — run_celltype_interaction","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq[1:50, 1:20] celltype <- data$celltype  data <- data@assays$RNA@data sample <- sample( c(\"patient1\", \"patient2\", \"patient3\"), ncol(data) , replace= TRUE ) x <- sample(1:100, ncol(data) , replace = TRUE) y <- sample(1:100, ncol(data) , replace = TRUE) spatialCoords <- list( x , y) alldata <- list(data = data, sample = sample, celltype = celltype,  spatialCoords  = spatialCoords )  feature_celltype_interaction <- run_celltype_interaction(     alldata, type = \"spatial_p\", ncores = 1 ) #> Error in check_data(data, type): Please ensure the data contain x_cord and y_cord."},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_cor.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate overall aggregated gene correlation — run_gene_cor","title":"Generate overall aggregated gene correlation — run_gene_cor","text":"function computes correlation gene expression across samples. user can specify genes interest, let function use top variable genes default. function supports scRNA-seq, spatial proteomics, spatial transcriptomics.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_cor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate overall aggregated gene correlation — run_gene_cor","text":"","code":"run_gene_cor(   data,   type = \"scrna\",   genes = NULL,   num_top_gene = NULL,   ncores = 1 )"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_cor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate overall aggregated gene correlation — run_gene_cor","text":"data list object containing data matrix celltype sample vector. type type dataset, either \"scrna\", \"spatial_t\", \"spatial_p\". genes Default NULL, case top variable genes used. provided user, need format list containing genes interest, eg, genes <- c(GZMA\", \"GZMK\", \"CCR7\", \"RPL38\" ) num_top_gene Number top variable genes use genes provided. Defaults 5. ncores Number cores parallel processing.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_cor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate overall aggregated gene correlation — run_gene_cor","text":"dataframe samples x features features form gene 1, gene 2 ... etc, numbers representing proportion gene expressed across cells.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_cor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate overall aggregated gene correlation — run_gene_cor","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq[1:50, 1:20] celltype <- data$celltype sample <- data$sample data <- data@assays$RNA@data  alldata <- list(data = data, celltype = celltype, sample = sample )  feature_gene_cor <- run_gene_cor(    alldata, type = \"scrna\", num_top_gene = 5, ncores = 1  ) #> Error: BiocParallel errors #>   1 remote errors, element index: 1 #>   12 unevaluated and other errors #>   first remote error: #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'rowVars': invalid class \"DelayedArray\" object:  #>     the supplied seed must have dimensions"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_cor_celltype.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate cell type specific gene expression correlation — run_gene_cor_celltype","title":"Generate cell type specific gene expression correlation — run_gene_cor_celltype","text":"function computes correlation expression set genes cell type input data. input data can three types: 'scrna', 'spatial_p' 'spatial_t'. genes parameter provided user, top variable genes selected based num_top_gene parameter (defaults 100).","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_cor_celltype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate cell type specific gene expression correlation — run_gene_cor_celltype","text":"","code":"run_gene_cor_celltype(   data,   type = \"scrna\",   genes = NULL,   num_top_gene = NULL,   ncores = 1 )"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_cor_celltype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate cell type specific gene expression correlation — run_gene_cor_celltype","text":"data list object containing data matrix celltype sample vector. type type dataset, either \"scrna\", \"spatial_t\", \"spatial_p\". genes Optional dataframe 2 columns: 'marker' 'celltype'. 'marker' column contain genes interest (e.g. 'S100A11', 'CCL4'), 'celltype' column contain celltype gene expression computed (e.g. 'CD8', 'B cells'). provided, top variable genes used based num_top_gene parameter. num_top_gene Number top genes use genes provided. Defaults 5. ncores Number cores parallel processing.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_cor_celltype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate cell type specific gene expression correlation — run_gene_cor_celltype","text":"dataframe samples x features. features form gene 1 vs gene 2 cell type , gene 1 vs gene 3 cell type b ... etc, numbers representing correlation two given genes given cell type.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_cor_celltype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate cell type specific gene expression correlation — run_gene_cor_celltype","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq[1:50, 1:20] celltype <- data$celltype sample <- data$sample data <- data@assays$RNA@data  alldata <- list(data = data, celltype = celltype, sample = sample )  feature_gene_cor_celltype <- run_gene_cor_celltype(    alldata,    type = \"scrna\", num_top_gene = 5, ncores = 1  ) #> Error: BiocParallel errors #>   1 remote errors, element index: 1 #>   12 unevaluated and other errors #>   first remote error: #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'rowVars': invalid class \"DelayedArray\" object:  #>     the supplied seed must have dimensions"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate overall aggregated mean expression — run_gene_mean","title":"Generate overall aggregated mean expression — run_gene_mean","text":"function computes mean expression genes across samples. user can specify genes interest, let function use top variable genes default. function supports scRNA-seq, spatial proteomics, spatial transcriptomics.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate overall aggregated mean expression — run_gene_mean","text":"","code":"run_gene_mean(   data,   type = \"scrna\",   genes = NULL,   num_top_gene = NULL,   ncores = 1 )"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate overall aggregated mean expression — run_gene_mean","text":"data list object containing data matrix celltype sample vector. type type dataset, either \"scrna\", \"spatial_t\", \"spatial_p\". genes Default NULL, case top variable genes used. provided user, need format list containing genes interest, eg, genes <- c(GZMA\", \"GZMK\", \"CCR7\", \"RPL38\" ) num_top_gene Number top variable genes use genes provided. Defaults 1500. ncores Number cores parallel processing.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate overall aggregated mean expression — run_gene_mean","text":"dataframe samples x features features form gene 1, gene 2 ... etc, numbers representing averaged gene expression across cells.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate overall aggregated mean expression — run_gene_mean","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq celltype <- data$celltype sample <- data$sample data <- data@assays$RNA@data  alldata <- list(data = data, celltype = celltype, sample = sample ) feature_gene_mean <- run_gene_mean(     alldata,     type = \"scrna\", num_top_gene = 150, ncores = 1 )"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_mean_celltype.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate cell type specific gene mean expression — run_gene_mean_celltype","title":"Generate cell type specific gene mean expression — run_gene_mean_celltype","text":"function computes mean expression set genes cell type input data. input data can three types: 'scrna', 'spatial_p' 'spatial_t'. genes parameter p rovided user, top variable genes selected based num_top_gene parameter (defaults 100).","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_mean_celltype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate cell type specific gene mean expression — run_gene_mean_celltype","text":"","code":"run_gene_mean_celltype(   data,   type = \"scrna\",   genes = NULL,   num_top_gene = NULL,   ncores = 1 )"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_mean_celltype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate cell type specific gene mean expression — run_gene_mean_celltype","text":"data list object containing data matrix celltype sample vector. type type dataset, either \"scrna\", \"spatial_t\", \"spatial_p\". genes Optional dataframe 2 columns: 'marker' 'celltype'. 'marker' column contain genes interest (e.g. 'S100A11', 'CCL4'), 'celltype' column contain celltype gene expression computed (e.g. 'CD8', 'B cells'). provided, top variable genes used based num_top_gene parameter. num_top_gene Number top genes use genes provided. Defaults 100. ncores Number cores parallel processing.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_mean_celltype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate cell type specific gene mean expression — run_gene_mean_celltype","text":"dataframe samples x features. features form gene 1 celltype , gene 2 celltype b ... etc, number representing average gene expression given gene across cells given celltype.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_mean_celltype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate cell type specific gene mean expression — run_gene_mean_celltype","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq[, 1:20] celltype <- data$celltype sample <- data$sample data <- data@assays$RNA@data  alldata <- list(data = data, celltype = celltype, sample = sample )  feature_gene_mean_celltype <- run_gene_mean_celltype(     alldata,     type = \"scrna\", num_top_gene = 100, ncores = 1   ) #> Error: BiocParallel errors #>   1 remote errors, element index: 1 #>   12 unevaluated and other errors #>   first remote error: #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'rowVars': invalid class \"DelayedArray\" object:  #>     the supplied seed must have dimensions"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_prop.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate overall aggregated gene proportion expression — run_gene_prop","title":"Generate overall aggregated gene proportion expression — run_gene_prop","text":"function computes proportion gene expression across samples. user can specify genes interest, let function use top variable genes default. function supports scRNA-seq, spatial proteomics, spatial transcriptomics.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_prop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate overall aggregated gene proportion expression — run_gene_prop","text":"","code":"run_gene_prop(   data,   type = \"scrna\",   genes = NULL,   num_top_gene = NULL,   ncores = 1 )"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_prop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate overall aggregated gene proportion expression — run_gene_prop","text":"data list object containing data matrix celltype sample vector. type type dataset, either \"scrna\", \"spatial_t\", \"spatial_p\". genes Default NULL, case top variable genes used. provided user, need format list containing genes interest, eg, genes <- c(GZMA\", \"GZMK\", \"CCR7\", \"RPL38\" ) num_top_gene Number top variable genes use genes provided. Defaults 1500. ncores Number cores parallel processing.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_prop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate overall aggregated gene proportion expression — run_gene_prop","text":"dataframe samples x features features form gene 1 vs gene 2, gene 1 vs gene 3 ... etc, numbers representing correlation gene expressions.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_prop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate overall aggregated gene proportion expression — run_gene_prop","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq[1:50, 1:20] celltype <- data$celltype sample <- data$sample data <- data@assays$RNA@data  alldata <- list(data = data, celltype = celltype, sample = sample ) feature_gene_prop <- run_gene_prop(alldata, type = \"scrna\", num_top_gene = 1500, ncores = 1) #> Error: BiocParallel errors #>   1 remote errors, element index: 1 #>   12 unevaluated and other errors #>   first remote error: #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'rowVars': invalid class \"DelayedArray\" object:  #>     the supplied seed must have dimensions"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_prop_celltype.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate cell type specific gene proportion expression — run_gene_prop_celltype","title":"Generate cell type specific gene proportion expression — run_gene_prop_celltype","text":"function computes proportion expression set genes cell type input data. input data can three types: 'scrna', 'spatial_p' 'spatial_t'. genes parameter provided user, top variable genes selected based num_top_gene parameter (defaults 100).","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_prop_celltype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate cell type specific gene proportion expression — run_gene_prop_celltype","text":"","code":"run_gene_prop_celltype(   data,   type = \"scrna\",   genes = NULL,   num_top_gene = NULL,   ncores = 1 )"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_prop_celltype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate cell type specific gene proportion expression — run_gene_prop_celltype","text":"data list object containing data matrix celltype sample vector. type type dataset, either \"scrna\", \"spatial_t\", \"spatial_p\". genes Optional dataframe 2 columns: 'marker' 'celltype'. 'marker' column contain genes interest (e.g. 'S100A11', 'CCL4'), 'celltype' column contain celltype gene expression computed (e.g. 'CD8', 'B cells'). provided, top variable genes used based num_top_gene parameter. num_top_gene Number top genes use genes provided. Defaults 100. ncores Number cores parallel processing.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_prop_celltype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate cell type specific gene proportion expression — run_gene_prop_celltype","text":"dataframe samples x features. features form gene 1 celltype , gene 2 celltype b ... etc, number representing proportion gene expression given gene across cells given celltype.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_gene_prop_celltype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate cell type specific gene proportion expression — run_gene_prop_celltype","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq[, 1:20] celltype <- data$celltype sample <- data$sample data <- data@assays$RNA@data  alldata <- list(data = data, celltype = celltype, sample = sample )  feature_gene_prop_celltype <- run_gene_prop_celltype(     alldata,     type = \"scrna\", num_top_gene = 100, ncores = 1  ) #> Error: BiocParallel errors #>   1 remote errors, element index: 1 #>   12 unevaluated and other errors #>   first remote error: #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'rowVars': invalid class \"DelayedArray\" object:  #>     the supplied seed must have dimensions"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_nn_correlation.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate nearest neighbour correlation — run_nn_correlation","title":"Generate nearest neighbour correlation — run_nn_correlation","text":"function calculates nearest neighbour correlation feature (eg, proteins) sample. calculated taking correlation cell nearest neighbours cell particular feature. function supports spatial proteomics, spatial transcriptomics.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_nn_correlation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate nearest neighbour correlation — run_nn_correlation","text":"","code":"run_nn_correlation(data, type = \"spatial_p\", num_top_gene = NULL, ncores = 1)"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_nn_correlation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate nearest neighbour correlation — run_nn_correlation","text":"data list object containing data matrix celltype sample vector. type type dataset, either \"scrna\", \"spatial_t\", \"spatial_p\". num_top_gene Number top variable genes use genes provided. Defaults 1500. ncores Number cores parallel processing.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_nn_correlation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate nearest neighbour correlation — run_nn_correlation","text":"dataframe samples x features features form protein 1, protein 2 ... etc, numbers representing Pearson's correlation.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_nn_correlation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate nearest neighbour correlation — run_nn_correlation","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq[1:50, 1:20] celltype <- data$celltype  data <- data@assays$RNA@data sample <- sample( c(\"patient1\", \"patient2\", \"patient3\"), ncol(data) , replace= TRUE ) x <- sample(1:100, ncol(data) , replace = TRUE) y <- sample(1:100, ncol(data) , replace = TRUE) spatialCoords <- list( x , y) alldata <- list(data = data, sample = sample, celltype = celltype,  spatialCoords  = spatialCoords ) feature_nn_correlation <- run_nn_correlation(     alldata, type = \"spatial_p\", ncores = 1 ) #> Error in check_data(data, type): Please ensure the data contain x_cord and y_cord."},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_pathway_gsva.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate pathway score using gene set enrichement analysis — run_pathway_gsva","title":"Generate pathway score using gene set enrichement analysis — run_pathway_gsva","text":"function calculates pathway scores given input dataset gene set using gene set enrichment analysis (GSVA). supports scRNA-seq, spatial proteomics spatial transcriptomics. currently supports two pathway analysis methods: ssgsea aucell. default, uses 50 hallmark gene sets msigdb. Alternatively, users can provide gene sets interest list format.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_pathway_gsva.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate pathway score using gene set enrichement analysis — run_pathway_gsva","text":"","code":"run_pathway_gsva(   data,   method = \"ssgsea\",   geneset = NULL,   species = \"Homo sapiens\",   type = \"scrna\",   subsample = TRUE,   ncores = 1 )"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_pathway_gsva.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate pathway score using gene set enrichement analysis — run_pathway_gsva","text":"data list object containing data matrix celltype sample vector. method Type pathway analysis method, currently support ssgsea aucell geneset default (geneset argument specified), use 50 hallmark gene set msigdb. users can also provide geneset interest list format, list entry containing vector names genes gene set. eg, geneset <- list(\"pathway_a\" = c(\"CAPN1\", ...), \"pathway_b\" = c(\"PEX6\")) species Whether species \"Homo sapiens\" \"Mus musculus\". Default \"Homo sapiens\". type type dataset, either \"scrna\", \"spatial_t\", \"spatial_p\". subsample Whether subsample, either TRUE FALSE. larger datasets (eg, 30,000 cells), subsample function can used increase speed. ncores Number cores parallel processing.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_pathway_gsva.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate pathway score using gene set enrichement analysis — run_pathway_gsva","text":"dataframe samples x features features form pathway 1 celltype , pathway 2 celltype b ... etc, number representing gene set enrichment score given pathway cells given celltype.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_pathway_gsva.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate pathway score using gene set enrichement analysis — run_pathway_gsva","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq[, 1:20] celltype <- data$celltype sample <- data$sample data <- data@assays$RNA@data  alldata <- list(data = data, celltype = celltype, sample = sample )  feature_pathway_gsva <- run_pathway_gsva(     alldata,     geneset = NULL, species = \"Homo sapiens\",     type = \"scrna\", subsample = FALSE, ncores = 1  ) #> Warning: 13 genes with constant expression values throuhgout the samples. #> Error: BiocParallel errors #>   1 remote errors, element index: 1 #>   12 unevaluated and other errors #>   first remote error: #> Error in this_sample[, index]: incorrect number of dimensions"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_pathway_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate pathway score using expression level — run_pathway_mean","title":"Generate pathway score using expression level — run_pathway_mean","text":"function calculates pathway scores given dataset gene set using gene expression levels. supports scRNA-seq, spatial transcriptomics spatial proteomics spatial transcriptomics). default, uses 50 hallmark gene sets msigdb. Alternatively, users can provide gene sets interest list format.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_pathway_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate pathway score using expression level — run_pathway_mean","text":"","code":"run_pathway_mean(   data,   geneset = NULL,   species = \"Homo sapiens\",   type = \"scrna\",   ncores = 1 )"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_pathway_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate pathway score using expression level — run_pathway_mean","text":"data list object containing data matrix celltype sample vector. geneset default (geneset argument specified), use 50 hallmark gene set msigdb. users can also provide geneset interest list format, list entry containing vector names genes gene set. eg, geneset <- list(\"pathway_a\" = c(\"CANS1\", ...), \"pathway_b\" = c(\"PEX6\")) species Whether species \"Homo sapiens\" \"Mus musculus\". Default \"Homo sapiens\". type type dataset, either \"scrna\", \"spatial_t\", \"spatial_p\". ncores Number cores parallel processing.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_pathway_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate pathway score using expression level — run_pathway_mean","text":"dataframe samples x features features form pathway 1 celltype , pathway 2 celltype b ... etc, number representing averaged expression given pathway cells given celltype.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_pathway_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate pathway score using expression level — run_pathway_mean","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq[1:50, 1:20] celltype <- data$celltype sample <- data$sample data <- data@assays$RNA@data  alldata <- list(data = data, celltype = celltype, sample = sample )  feature_pathway_mean <- run_pathway_mean(     data,     geneset = NULL, species = \"Homo sapiens\",     type = \"scrna\", ncores = 1  ) #> Error in check_data(data, type): Please make sure you provide the data"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_pathway_prop.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate pathway score using proportion of expression — run_pathway_prop","title":"Generate pathway score using proportion of expression — run_pathway_prop","text":"function calculates pathway scores given input dataset gene set using proportion gene expression levels. supports scRNA-seq, spatial transcriptomics spatial proteomics spatial transcriptomics). default, uses 50 hallmark gene sets msigdb. Alternatively, users can provide gene sets interest list format.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_pathway_prop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate pathway score using proportion of expression — run_pathway_prop","text":"","code":"run_pathway_prop(   data,   geneset = NULL,   species = \"Homo sapiens\",   type = \"scrna\",   ncores = 1 )"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_pathway_prop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate pathway score using proportion of expression — run_pathway_prop","text":"data list object containing data matrix celltype sample vector. geneset default (geneset argument specified), use 50 hallmark gene set msigdb. users can also provide geneset interest list format, list entry containing vector names genes gene set. eg, geneset <- list(\"pathway_a\" = c(\"CANS1\", ...), \"pathway_b\" = c(\"PEX6\")) species Whether species \"Homo sapiens\" \"Mus musculus\". Default \"Homo sapiens\". type type dataset, either \"scrna\", \"spatial_t\", \"spatial_p\". ncores Number cores parallel processing.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_pathway_prop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate pathway score using proportion of expression — run_pathway_prop","text":"dataframe samples x features features form pathway 1 celltype , pathway 2 celltype b ... etc, number representing proportion expression given pathway cells given celltype.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_pathway_prop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate pathway score using proportion of expression — run_pathway_prop","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq[1:20, 1:20] celltype <- data$celltype sample <- data$sample data <- data@assays$RNA@data  alldata <- list(data = data, celltype = celltype, sample = sample )  feature_pathway_prop <- run_pathway_prop(     alldata,     geneset = NULL, species = \"Homo sapiens\",     type = \"scrna\", ncores = 1  ) #> Error: BiocParallel errors #>   1 remote errors, element index: 2 #>   48 unevaluated and other errors #>   first remote error: #> Error in quantile.default(expression_level, 0.75): missing values and NaN's not allowed if 'na.rm' is FALSE"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_proportion_logit.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate cell type proportions, with logit transformation — run_proportion_logit","title":"Generate cell type proportions, with logit transformation — run_proportion_logit","text":"function calculates proportions cells belonging cell type, applies logit transformation proportions. input data must contain sample celltype metadata column. function supports scRNA-seq spatial proteomics. function returns dataframe samples rows cell types columns.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_proportion_logit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate cell type proportions, with logit transformation — run_proportion_logit","text":"","code":"run_proportion_logit(data, type = \"scrna\", ncores = 1)"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_proportion_logit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate cell type proportions, with logit transformation — run_proportion_logit","text":"data list object containing data matrix celltype sample vector. type type dataset, either \"scrna\", \"spatial_t\", \"spatial_p\". ncores Number cores parallel processing.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_proportion_logit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate cell type proportions, with logit transformation — run_proportion_logit","text":"dataframe samples x features features form celltype , celltype b, number representing proportions.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_proportion_logit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate cell type proportions, with logit transformation — run_proportion_logit","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq[1:50, 1:20] celltype <- data$celltype sample <- data$sample data <- data@assays$RNA@data  alldata <- list(data = data, celltype = celltype, sample = sample )  feature_proportion_logit <- run_proportion_logit(     alldata,     type = \"scrna\", ncores = 1 )"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_proportion_ratio.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate cell type proportion ratio — run_proportion_ratio","title":"Generate cell type proportion ratio — run_proportion_ratio","text":"function calculates pairwise cell type proportion ratio sample. applies logit transformation proportions. input data must contain sample celltype metadata column. function supports scRNA-seq spatial proteomics. function returns dataframe samples rows cell types columns.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_proportion_ratio.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate cell type proportion ratio — run_proportion_ratio","text":"","code":"run_proportion_ratio(data, type = \"scrna\", ncores = 1)"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_proportion_ratio.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate cell type proportion ratio — run_proportion_ratio","text":"data list object containing data matrix celltype sample vector. type type dataset, either \"scrna\", \"spatial_t\", \"spatial_p\". ncores Number cores parallel processing.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_proportion_ratio.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate cell type proportion ratio — run_proportion_ratio","text":"dataframe samples x features. features form celltype vs celltype b, celltype vs celltype c, number representing ratio two cell types.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_proportion_ratio.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate cell type proportion ratio — run_proportion_ratio","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq[1:50, 1:20]  celltype <- data$celltype sample <- data$sample data <- data@assays$RNA@data  alldata <- list(data = data, celltype = celltype, sample = sample )  feature_proportion_ratio <- run_proportion_ratio(     alldata,     type = \"scrna\", ncores = 1 )"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_proportion_raw.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate cell type proportion raw — run_proportion_raw","title":"Generate cell type proportion raw — run_proportion_raw","text":"function calculates proportions cells belonging cell type. input data must contain sample celltype metadata column. function supports scRNA-seq spatial proteomics. function returns dataframe samples rows cell types columns.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_proportion_raw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate cell type proportion raw — run_proportion_raw","text":"","code":"run_proportion_raw(data, type = \"scrna\", ncores = 1)"},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_proportion_raw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate cell type proportion raw — run_proportion_raw","text":"data list object containing data matrix celltype sample vector. type type dataset, either \"scrna\", \"spatial_t\", \"spatial_p\". ncores Number cores parallel processing.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_proportion_raw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate cell type proportion raw — run_proportion_raw","text":"dataframe samples x features. features form celltype , celltype b, number representing proportions.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/run_proportion_raw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate cell type proportion raw — run_proportion_raw","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\") data <- example_scrnaseq[1:50, 1:20]  celltype <- data$celltype sample <- data$sample data <- data@assays$RNA@data  alldata <- list(data = data, celltype = celltype, sample = sample )  feature_proportion_raw <- run_proportion_raw(     alldata,     type = \"scrna\", ncores = 1 )"},{"path":"https://sydneybiox.github.io/scFeatures/reference/scFeatures.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrapper function to run all feature types in scFeatures — scFeatures","title":"Wrapper function to run all feature types in scFeatures — scFeatures","text":"scFeatures function generates variety features Seurat object containing single cell RNA-sequencing data. default, feature types generated returned single list containing multiple data frames.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/scFeatures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrapper function to run all feature types in scFeatures — scFeatures","text":"","code":"scFeatures(   data = NULL,   sample = NULL,   celltype = NULL,   spatialCoords = NULL,   spotProbability = NULL,   feature_types = NULL,   type = \"scrna\",   ncores = 1,   species = \"Homo sapiens\",   celltype_genes = NULL,   aggregated_genes = NULL,   geneset = NULL )"},{"path":"https://sydneybiox.github.io/scFeatures/reference/scFeatures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrapper function to run all feature types in scFeatures — scFeatures","text":"data input data, matrix genes cells sample vector sample information celltype vector cell type information spatialCoords list two vectors containing x y coordinates cell spotProbability matrix spot probability, row represents celltype column represents spot feature_types vector containing name feature types generate, options \"proportion_raw\", \"proportion_logit\" , \"proportion_ratio\", \"gene_mean_celltype\", \"gene_prop_celltype\", \"gene_cor_celltype\", \"pathway_gsva\" , \"pathway_mean\", \"pathway_prop\", \"CCI\", \"gene_mean_aggregated\", \"gene_prop_aggregated\", 'gene_cor_aggregated', \"L_stats\" , \"celltype_interaction\" , \"morans_I\", \"nn_correlation\". value provided, feature types generated. type input data type, either \"scrna\" (stands single-cell RNA-sequencing data), \"spatial_p\" (stands spatial proteomics data), \"spatial_t\" (stands single cell spatial data ) ncores number cores , default 1 species either \"Homo sapiens\" \"Mus musculus\". Defaults \"Homo sapiens\" value provided celltype_genes genes interest celltype specific gene expression feature category value provided, top variable genes used aggregated_genes genes interest overall aggregated gene expression feature category value provided, top variable genes used geneset geneset interest celltype specific pathway feature category value provided, 50 hallmark pathways used","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/scFeatures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrapper function to run all feature types in scFeatures — scFeatures","text":"list dataframes containing generated feature matrix form sample x features","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/scFeatures.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrapper function to run all feature types in scFeatures — scFeatures","text":"","code":"data(\"example_scrnaseq\" , package = \"scFeatures\")  data <- example_scrnaseq celltype <- data$celltype sample <- data$sample data <- data@assays$RNA@data scfeatures_result <- scFeatures(data, celltype = celltype, sample = sample, type = \"scrna\", feature_types = \"proportion_raw\") #> generating proportion raw features"},{"path":"https://sydneybiox.github.io/scFeatures/reference/scfeatures_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of scFeatures() output — scfeatures_result","title":"Example of scFeatures() output — scfeatures_result","text":"example output scFeatures() function example_scrnaseq.","code":""},{"path":"https://sydneybiox.github.io/scFeatures/reference/scfeatures_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of scFeatures() output — scfeatures_result","text":"","code":"data(\"scfeatures_result\")"},{"path":[]},{"path":"https://sydneybiox.github.io/scFeatures/reference/scfeatures_result.html","id":"scfeatures-result","dir":"Reference","previous_headings":"","what":"scfeatures_result","title":"Example of scFeatures() output — scfeatures_result","text":"list two dataframes. dataframe columns patient rows feature values. first dataframe contains feature type \"proportion_raw\". second dataframe contains feature type \"proportion_logit\".","code":""}]
